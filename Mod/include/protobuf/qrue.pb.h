// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qrue.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_qrue_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_qrue_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_qrue_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_qrue_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_qrue_2eproto;
class Il2CppClassInfo;
struct Il2CppClassInfoDefaultTypeInternal;
extern Il2CppClassInfoDefaultTypeInternal _Il2CppClassInfo_default_instance_;
class Il2CppData;
struct Il2CppDataDefaultTypeInternal;
extern Il2CppDataDefaultTypeInternal _Il2CppData_default_instance_;
class Il2CppFieldInfo;
struct Il2CppFieldInfoDefaultTypeInternal;
extern Il2CppFieldInfoDefaultTypeInternal _Il2CppFieldInfo_default_instance_;
class Il2CppMethodInfo;
struct Il2CppMethodInfoDefaultTypeInternal;
extern Il2CppMethodInfoDefaultTypeInternal _Il2CppMethodInfo_default_instance_;
class Il2CppPropertyInfo;
struct Il2CppPropertyInfoDefaultTypeInternal;
extern Il2CppPropertyInfoDefaultTypeInternal _Il2CppPropertyInfo_default_instance_;
class Il2CppType;
struct Il2CppTypeDefaultTypeInternal;
extern Il2CppTypeDefaultTypeInternal _Il2CppType_default_instance_;
class InvokeMethod;
struct InvokeMethodDefaultTypeInternal;
extern InvokeMethodDefaultTypeInternal _InvokeMethod_default_instance_;
class InvokeMethodResult;
struct InvokeMethodResultDefaultTypeInternal;
extern InvokeMethodResultDefaultTypeInternal _InvokeMethodResult_default_instance_;
class LoadObject;
struct LoadObjectDefaultTypeInternal;
extern LoadObjectDefaultTypeInternal _LoadObject_default_instance_;
class LoadObjectResult;
struct LoadObjectResultDefaultTypeInternal;
extern LoadObjectResultDefaultTypeInternal _LoadObjectResult_default_instance_;
class PacketWrapper;
struct PacketWrapperDefaultTypeInternal;
extern PacketWrapperDefaultTypeInternal _PacketWrapper_default_instance_;
class SearchObjects;
struct SearchObjectsDefaultTypeInternal;
extern SearchObjectsDefaultTypeInternal _SearchObjects_default_instance_;
class SearchObjectsResult;
struct SearchObjectsResultDefaultTypeInternal;
extern SearchObjectsResultDefaultTypeInternal _SearchObjectsResult_default_instance_;
class TypeInfo;
struct TypeInfoDefaultTypeInternal;
extern TypeInfoDefaultTypeInternal _TypeInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Il2CppClassInfo* Arena::CreateMaybeMessage<::Il2CppClassInfo>(Arena*);
template<> ::Il2CppData* Arena::CreateMaybeMessage<::Il2CppData>(Arena*);
template<> ::Il2CppFieldInfo* Arena::CreateMaybeMessage<::Il2CppFieldInfo>(Arena*);
template<> ::Il2CppMethodInfo* Arena::CreateMaybeMessage<::Il2CppMethodInfo>(Arena*);
template<> ::Il2CppPropertyInfo* Arena::CreateMaybeMessage<::Il2CppPropertyInfo>(Arena*);
template<> ::Il2CppType* Arena::CreateMaybeMessage<::Il2CppType>(Arena*);
template<> ::InvokeMethod* Arena::CreateMaybeMessage<::InvokeMethod>(Arena*);
template<> ::InvokeMethodResult* Arena::CreateMaybeMessage<::InvokeMethodResult>(Arena*);
template<> ::LoadObject* Arena::CreateMaybeMessage<::LoadObject>(Arena*);
template<> ::LoadObjectResult* Arena::CreateMaybeMessage<::LoadObjectResult>(Arena*);
template<> ::PacketWrapper* Arena::CreateMaybeMessage<::PacketWrapper>(Arena*);
template<> ::SearchObjects* Arena::CreateMaybeMessage<::SearchObjects>(Arena*);
template<> ::SearchObjectsResult* Arena::CreateMaybeMessage<::SearchObjectsResult>(Arena*);
template<> ::TypeInfo* Arena::CreateMaybeMessage<::TypeInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TypeInfo_Type : int {
  TypeInfo_Type_PRIMITIVE = 0,
  TypeInfo_Type_STRUCT = 1,
  TypeInfo_Type_CLASS = 2,
  TypeInfo_Type_TypeInfo_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TypeInfo_Type_TypeInfo_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TypeInfo_Type_IsValid(int value);
constexpr TypeInfo_Type TypeInfo_Type_Type_MIN = TypeInfo_Type_PRIMITIVE;
constexpr TypeInfo_Type TypeInfo_Type_Type_MAX = TypeInfo_Type_CLASS;
constexpr int TypeInfo_Type_Type_ARRAYSIZE = TypeInfo_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TypeInfo_Type_descriptor();
template<typename T>
inline const std::string& TypeInfo_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TypeInfo_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TypeInfo_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TypeInfo_Type_descriptor(), enum_t_value);
}
inline bool TypeInfo_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TypeInfo_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TypeInfo_Type>(
    TypeInfo_Type_descriptor(), name, value);
}
enum TypeInfo_Primitive : int {
  TypeInfo_Primitive_BOOLEAN = 0,
  TypeInfo_Primitive_CHAR = 1,
  TypeInfo_Primitive_INT = 2,
  TypeInfo_Primitive_FLOAT = 3,
  TypeInfo_Primitive_STRING = 4,
  TypeInfo_Primitive_TypeInfo_Primitive_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TypeInfo_Primitive_TypeInfo_Primitive_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TypeInfo_Primitive_IsValid(int value);
constexpr TypeInfo_Primitive TypeInfo_Primitive_Primitive_MIN = TypeInfo_Primitive_BOOLEAN;
constexpr TypeInfo_Primitive TypeInfo_Primitive_Primitive_MAX = TypeInfo_Primitive_STRING;
constexpr int TypeInfo_Primitive_Primitive_ARRAYSIZE = TypeInfo_Primitive_Primitive_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TypeInfo_Primitive_descriptor();
template<typename T>
inline const std::string& TypeInfo_Primitive_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TypeInfo_Primitive>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TypeInfo_Primitive_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TypeInfo_Primitive_descriptor(), enum_t_value);
}
inline bool TypeInfo_Primitive_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TypeInfo_Primitive* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TypeInfo_Primitive>(
    TypeInfo_Primitive_descriptor(), name, value);
}
enum Il2CppData_Type : int {
  Il2CppData_Type_PRIMITIVE = 0,
  Il2CppData_Type_STRUCT = 1,
  Il2CppData_Type_CLASS = 2,
  Il2CppData_Type_Il2CppData_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Il2CppData_Type_Il2CppData_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Il2CppData_Type_IsValid(int value);
constexpr Il2CppData_Type Il2CppData_Type_Type_MIN = Il2CppData_Type_PRIMITIVE;
constexpr Il2CppData_Type Il2CppData_Type_Type_MAX = Il2CppData_Type_CLASS;
constexpr int Il2CppData_Type_Type_ARRAYSIZE = Il2CppData_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Il2CppData_Type_descriptor();
template<typename T>
inline const std::string& Il2CppData_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Il2CppData_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Il2CppData_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Il2CppData_Type_descriptor(), enum_t_value);
}
inline bool Il2CppData_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Il2CppData_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Il2CppData_Type>(
    Il2CppData_Type_descriptor(), name, value);
}
enum InvokeMethodResult_Status : int {
  InvokeMethodResult_Status_OK = 0,
  InvokeMethodResult_Status_ERR = 1,
  InvokeMethodResult_Status_NOT_FOUND = 2,
  InvokeMethodResult_Status_InvokeMethodResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InvokeMethodResult_Status_InvokeMethodResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InvokeMethodResult_Status_IsValid(int value);
constexpr InvokeMethodResult_Status InvokeMethodResult_Status_Status_MIN = InvokeMethodResult_Status_OK;
constexpr InvokeMethodResult_Status InvokeMethodResult_Status_Status_MAX = InvokeMethodResult_Status_NOT_FOUND;
constexpr int InvokeMethodResult_Status_Status_ARRAYSIZE = InvokeMethodResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InvokeMethodResult_Status_descriptor();
template<typename T>
inline const std::string& InvokeMethodResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InvokeMethodResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InvokeMethodResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InvokeMethodResult_Status_descriptor(), enum_t_value);
}
inline bool InvokeMethodResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InvokeMethodResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InvokeMethodResult_Status>(
    InvokeMethodResult_Status_descriptor(), name, value);
}
// ===================================================================

class Il2CppClassInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Il2CppClassInfo) */ {
 public:
  inline Il2CppClassInfo() : Il2CppClassInfo(nullptr) {}
  ~Il2CppClassInfo() override;
  explicit constexpr Il2CppClassInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Il2CppClassInfo(const Il2CppClassInfo& from);
  Il2CppClassInfo(Il2CppClassInfo&& from) noexcept
    : Il2CppClassInfo() {
    *this = ::std::move(from);
  }

  inline Il2CppClassInfo& operator=(const Il2CppClassInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Il2CppClassInfo& operator=(Il2CppClassInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Il2CppClassInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Il2CppClassInfo* internal_default_instance() {
    return reinterpret_cast<const Il2CppClassInfo*>(
               &_Il2CppClassInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Il2CppClassInfo& a, Il2CppClassInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Il2CppClassInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Il2CppClassInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Il2CppClassInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Il2CppClassInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Il2CppClassInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Il2CppClassInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Il2CppClassInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Il2CppClassInfo";
  }
  protected:
  explicit Il2CppClassInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespazeFieldNumber = 1,
    kClazzFieldNumber = 2,
  };
  // string namespaze = 1;
  void clear_namespaze();
  const std::string& namespaze() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespaze(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespaze();
  PROTOBUF_NODISCARD std::string* release_namespaze();
  void set_allocated_namespaze(std::string* namespaze);
  private:
  const std::string& _internal_namespaze() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespaze(const std::string& value);
  std::string* _internal_mutable_namespaze();
  public:

  // string clazz = 2;
  void clear_clazz();
  const std::string& clazz() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clazz(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clazz();
  PROTOBUF_NODISCARD std::string* release_clazz();
  void set_allocated_clazz(std::string* clazz);
  private:
  const std::string& _internal_clazz() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clazz(const std::string& value);
  std::string* _internal_mutable_clazz();
  public:

  // @@protoc_insertion_point(class_scope:Il2CppClassInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespaze_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clazz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class TypeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TypeInfo) */ {
 public:
  inline TypeInfo() : TypeInfo(nullptr) {}
  ~TypeInfo() override;
  explicit constexpr TypeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TypeInfo(const TypeInfo& from);
  TypeInfo(TypeInfo&& from) noexcept
    : TypeInfo() {
    *this = ::std::move(from);
  }

  inline TypeInfo& operator=(const TypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeInfo& operator=(TypeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeInfo* internal_default_instance() {
    return reinterpret_cast<const TypeInfo*>(
               &_TypeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TypeInfo& a, TypeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TypeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TypeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TypeInfo";
  }
  protected:
  explicit TypeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TypeInfo_Type Type;
  static constexpr Type PRIMITIVE =
    TypeInfo_Type_PRIMITIVE;
  static constexpr Type STRUCT =
    TypeInfo_Type_STRUCT;
  static constexpr Type CLASS =
    TypeInfo_Type_CLASS;
  static inline bool Type_IsValid(int value) {
    return TypeInfo_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TypeInfo_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TypeInfo_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TypeInfo_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TypeInfo_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TypeInfo_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TypeInfo_Type_Parse(name, value);
  }

  typedef TypeInfo_Primitive Primitive;
  static constexpr Primitive BOOLEAN =
    TypeInfo_Primitive_BOOLEAN;
  static constexpr Primitive CHAR =
    TypeInfo_Primitive_CHAR;
  static constexpr Primitive INT =
    TypeInfo_Primitive_INT;
  static constexpr Primitive FLOAT =
    TypeInfo_Primitive_FLOAT;
  static constexpr Primitive STRING =
    TypeInfo_Primitive_STRING;
  static inline bool Primitive_IsValid(int value) {
    return TypeInfo_Primitive_IsValid(value);
  }
  static constexpr Primitive Primitive_MIN =
    TypeInfo_Primitive_Primitive_MIN;
  static constexpr Primitive Primitive_MAX =
    TypeInfo_Primitive_Primitive_MAX;
  static constexpr int Primitive_ARRAYSIZE =
    TypeInfo_Primitive_Primitive_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Primitive_descriptor() {
    return TypeInfo_Primitive_descriptor();
  }
  template<typename T>
  static inline const std::string& Primitive_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Primitive>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Primitive_Name.");
    return TypeInfo_Primitive_Name(enum_t_value);
  }
  static inline bool Primitive_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Primitive* value) {
    return TypeInfo_Primitive_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClassInfoFieldNumber = 3,
    kTypeFieldNumber = 1,
    kPrimitiveTypeFieldNumber = 2,
  };
  // .Il2CppClassInfo classInfo = 3;
  bool has_classinfo() const;
  private:
  bool _internal_has_classinfo() const;
  public:
  void clear_classinfo();
  const ::Il2CppClassInfo& classinfo() const;
  PROTOBUF_NODISCARD ::Il2CppClassInfo* release_classinfo();
  ::Il2CppClassInfo* mutable_classinfo();
  void set_allocated_classinfo(::Il2CppClassInfo* classinfo);
  private:
  const ::Il2CppClassInfo& _internal_classinfo() const;
  ::Il2CppClassInfo* _internal_mutable_classinfo();
  public:
  void unsafe_arena_set_allocated_classinfo(
      ::Il2CppClassInfo* classinfo);
  ::Il2CppClassInfo* unsafe_arena_release_classinfo();

  // .TypeInfo.Type type = 1;
  void clear_type();
  ::TypeInfo_Type type() const;
  void set_type(::TypeInfo_Type value);
  private:
  ::TypeInfo_Type _internal_type() const;
  void _internal_set_type(::TypeInfo_Type value);
  public:

  // .TypeInfo.Primitive primitiveType = 2;
  void clear_primitivetype();
  ::TypeInfo_Primitive primitivetype() const;
  void set_primitivetype(::TypeInfo_Primitive value);
  private:
  ::TypeInfo_Primitive _internal_primitivetype() const;
  void _internal_set_primitivetype(::TypeInfo_Primitive value);
  public:

  // @@protoc_insertion_point(class_scope:TypeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Il2CppClassInfo* classinfo_;
  int type_;
  int primitivetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class Il2CppFieldInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Il2CppFieldInfo) */ {
 public:
  inline Il2CppFieldInfo() : Il2CppFieldInfo(nullptr) {}
  ~Il2CppFieldInfo() override;
  explicit constexpr Il2CppFieldInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Il2CppFieldInfo(const Il2CppFieldInfo& from);
  Il2CppFieldInfo(Il2CppFieldInfo&& from) noexcept
    : Il2CppFieldInfo() {
    *this = ::std::move(from);
  }

  inline Il2CppFieldInfo& operator=(const Il2CppFieldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Il2CppFieldInfo& operator=(Il2CppFieldInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Il2CppFieldInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Il2CppFieldInfo* internal_default_instance() {
    return reinterpret_cast<const Il2CppFieldInfo*>(
               &_Il2CppFieldInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Il2CppFieldInfo& a, Il2CppFieldInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Il2CppFieldInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Il2CppFieldInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Il2CppFieldInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Il2CppFieldInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Il2CppFieldInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Il2CppFieldInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Il2CppFieldInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Il2CppFieldInfo";
  }
  protected:
  explicit Il2CppFieldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .Il2CppData type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::Il2CppData& type() const;
  PROTOBUF_NODISCARD ::Il2CppData* release_type();
  ::Il2CppData* mutable_type();
  void set_allocated_type(::Il2CppData* type);
  private:
  const ::Il2CppData& _internal_type() const;
  ::Il2CppData* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::Il2CppData* type);
  ::Il2CppData* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:Il2CppFieldInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::Il2CppData* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class Il2CppPropertyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Il2CppPropertyInfo) */ {
 public:
  inline Il2CppPropertyInfo() : Il2CppPropertyInfo(nullptr) {}
  ~Il2CppPropertyInfo() override;
  explicit constexpr Il2CppPropertyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Il2CppPropertyInfo(const Il2CppPropertyInfo& from);
  Il2CppPropertyInfo(Il2CppPropertyInfo&& from) noexcept
    : Il2CppPropertyInfo() {
    *this = ::std::move(from);
  }

  inline Il2CppPropertyInfo& operator=(const Il2CppPropertyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Il2CppPropertyInfo& operator=(Il2CppPropertyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Il2CppPropertyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Il2CppPropertyInfo* internal_default_instance() {
    return reinterpret_cast<const Il2CppPropertyInfo*>(
               &_Il2CppPropertyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Il2CppPropertyInfo& a, Il2CppPropertyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Il2CppPropertyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Il2CppPropertyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Il2CppPropertyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Il2CppPropertyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Il2CppPropertyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Il2CppPropertyInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Il2CppPropertyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Il2CppPropertyInfo";
  }
  protected:
  explicit Il2CppPropertyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 5,
    kHasGetFieldNumber = 3,
    kHasSetFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .Il2CppData type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::Il2CppData& type() const;
  PROTOBUF_NODISCARD ::Il2CppData* release_type();
  ::Il2CppData* mutable_type();
  void set_allocated_type(::Il2CppData* type);
  private:
  const ::Il2CppData& _internal_type() const;
  ::Il2CppData* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::Il2CppData* type);
  ::Il2CppData* unsafe_arena_release_type();

  // bool hasGet = 3;
  void clear_hasget();
  bool hasget() const;
  void set_hasget(bool value);
  private:
  bool _internal_hasget() const;
  void _internal_set_hasget(bool value);
  public:

  // bool hasSet = 4;
  void clear_hasset();
  bool hasset() const;
  void set_hasset(bool value);
  private:
  bool _internal_hasset() const;
  void _internal_set_hasset(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Il2CppPropertyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::Il2CppData* type_;
  bool hasget_;
  bool hasset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class Il2CppMethodInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Il2CppMethodInfo) */ {
 public:
  inline Il2CppMethodInfo() : Il2CppMethodInfo(nullptr) {}
  ~Il2CppMethodInfo() override;
  explicit constexpr Il2CppMethodInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Il2CppMethodInfo(const Il2CppMethodInfo& from);
  Il2CppMethodInfo(Il2CppMethodInfo&& from) noexcept
    : Il2CppMethodInfo() {
    *this = ::std::move(from);
  }

  inline Il2CppMethodInfo& operator=(const Il2CppMethodInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Il2CppMethodInfo& operator=(Il2CppMethodInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Il2CppMethodInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Il2CppMethodInfo* internal_default_instance() {
    return reinterpret_cast<const Il2CppMethodInfo*>(
               &_Il2CppMethodInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Il2CppMethodInfo& a, Il2CppMethodInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Il2CppMethodInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Il2CppMethodInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Il2CppMethodInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Il2CppMethodInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Il2CppMethodInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Il2CppMethodInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Il2CppMethodInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Il2CppMethodInfo";
  }
  protected:
  explicit Il2CppMethodInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgNamesFieldNumber = 3,
    kArgTypesFieldNumber = 4,
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // repeated string argNames = 3;
  int argnames_size() const;
  private:
  int _internal_argnames_size() const;
  public:
  void clear_argnames();
  const std::string& argnames(int index) const;
  std::string* mutable_argnames(int index);
  void set_argnames(int index, const std::string& value);
  void set_argnames(int index, std::string&& value);
  void set_argnames(int index, const char* value);
  void set_argnames(int index, const char* value, size_t size);
  std::string* add_argnames();
  void add_argnames(const std::string& value);
  void add_argnames(std::string&& value);
  void add_argnames(const char* value);
  void add_argnames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& argnames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_argnames();
  private:
  const std::string& _internal_argnames(int index) const;
  std::string* _internal_add_argnames();
  public:

  // repeated .Il2CppData argTypes = 4;
  int argtypes_size() const;
  private:
  int _internal_argtypes_size() const;
  public:
  void clear_argtypes();
  ::Il2CppData* mutable_argtypes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >*
      mutable_argtypes();
  private:
  const ::Il2CppData& _internal_argtypes(int index) const;
  ::Il2CppData* _internal_add_argtypes();
  public:
  const ::Il2CppData& argtypes(int index) const;
  ::Il2CppData* add_argtypes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >&
      argtypes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Il2CppMethodInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> argnames_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData > argtypes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class Il2CppType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Il2CppType) */ {
 public:
  inline Il2CppType() : Il2CppType(nullptr) {}
  ~Il2CppType() override;
  explicit constexpr Il2CppType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Il2CppType(const Il2CppType& from);
  Il2CppType(Il2CppType&& from) noexcept
    : Il2CppType() {
    *this = ::std::move(from);
  }

  inline Il2CppType& operator=(const Il2CppType& from) {
    CopyFrom(from);
    return *this;
  }
  inline Il2CppType& operator=(Il2CppType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Il2CppType& default_instance() {
    return *internal_default_instance();
  }
  static inline const Il2CppType* internal_default_instance() {
    return reinterpret_cast<const Il2CppType*>(
               &_Il2CppType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Il2CppType& a, Il2CppType& b) {
    a.Swap(&b);
  }
  inline void Swap(Il2CppType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Il2CppType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Il2CppType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Il2CppType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Il2CppType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Il2CppType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Il2CppType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Il2CppType";
  }
  protected:
  explicit Il2CppType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGenericsFieldNumber = 3,
    kInterfacesFieldNumber = 5,
    kFieldsFieldNumber = 6,
    kPropertiesFieldNumber = 7,
    kMethodsFieldNumber = 8,
    kNamespazeFieldNumber = 1,
    kClazzFieldNumber = 2,
    kParentFieldNumber = 4,
  };
  // repeated .Il2CppClassInfo generics = 3;
  int generics_size() const;
  private:
  int _internal_generics_size() const;
  public:
  void clear_generics();
  ::Il2CppClassInfo* mutable_generics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppClassInfo >*
      mutable_generics();
  private:
  const ::Il2CppClassInfo& _internal_generics(int index) const;
  ::Il2CppClassInfo* _internal_add_generics();
  public:
  const ::Il2CppClassInfo& generics(int index) const;
  ::Il2CppClassInfo* add_generics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppClassInfo >&
      generics() const;

  // repeated .Il2CppType interfaces = 5;
  int interfaces_size() const;
  private:
  int _internal_interfaces_size() const;
  public:
  void clear_interfaces();
  ::Il2CppType* mutable_interfaces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppType >*
      mutable_interfaces();
  private:
  const ::Il2CppType& _internal_interfaces(int index) const;
  ::Il2CppType* _internal_add_interfaces();
  public:
  const ::Il2CppType& interfaces(int index) const;
  ::Il2CppType* add_interfaces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppType >&
      interfaces() const;

  // repeated .Il2CppFieldInfo fields = 6;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::Il2CppFieldInfo* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppFieldInfo >*
      mutable_fields();
  private:
  const ::Il2CppFieldInfo& _internal_fields(int index) const;
  ::Il2CppFieldInfo* _internal_add_fields();
  public:
  const ::Il2CppFieldInfo& fields(int index) const;
  ::Il2CppFieldInfo* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppFieldInfo >&
      fields() const;

  // repeated .Il2CppPropertyInfo properties = 7;
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  ::Il2CppPropertyInfo* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppPropertyInfo >*
      mutable_properties();
  private:
  const ::Il2CppPropertyInfo& _internal_properties(int index) const;
  ::Il2CppPropertyInfo* _internal_add_properties();
  public:
  const ::Il2CppPropertyInfo& properties(int index) const;
  ::Il2CppPropertyInfo* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppPropertyInfo >&
      properties() const;

  // repeated .Il2CppMethodInfo methods = 8;
  int methods_size() const;
  private:
  int _internal_methods_size() const;
  public:
  void clear_methods();
  ::Il2CppMethodInfo* mutable_methods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppMethodInfo >*
      mutable_methods();
  private:
  const ::Il2CppMethodInfo& _internal_methods(int index) const;
  ::Il2CppMethodInfo* _internal_add_methods();
  public:
  const ::Il2CppMethodInfo& methods(int index) const;
  ::Il2CppMethodInfo* add_methods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppMethodInfo >&
      methods() const;

  // string namespaze = 1;
  void clear_namespaze();
  const std::string& namespaze() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespaze(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespaze();
  PROTOBUF_NODISCARD std::string* release_namespaze();
  void set_allocated_namespaze(std::string* namespaze);
  private:
  const std::string& _internal_namespaze() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespaze(const std::string& value);
  std::string* _internal_mutable_namespaze();
  public:

  // string clazz = 2;
  void clear_clazz();
  const std::string& clazz() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clazz(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clazz();
  PROTOBUF_NODISCARD std::string* release_clazz();
  void set_allocated_clazz(std::string* clazz);
  private:
  const std::string& _internal_clazz() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clazz(const std::string& value);
  std::string* _internal_mutable_clazz();
  public:

  // .Il2CppType parent = 4;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::Il2CppType& parent() const;
  PROTOBUF_NODISCARD ::Il2CppType* release_parent();
  ::Il2CppType* mutable_parent();
  void set_allocated_parent(::Il2CppType* parent);
  private:
  const ::Il2CppType& _internal_parent() const;
  ::Il2CppType* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::Il2CppType* parent);
  ::Il2CppType* unsafe_arena_release_parent();

  // @@protoc_insertion_point(class_scope:Il2CppType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppClassInfo > generics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppType > interfaces_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppFieldInfo > fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppPropertyInfo > properties_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppMethodInfo > methods_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespaze_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clazz_;
  ::Il2CppType* parent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class Il2CppData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Il2CppData) */ {
 public:
  inline Il2CppData() : Il2CppData(nullptr) {}
  ~Il2CppData() override;
  explicit constexpr Il2CppData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Il2CppData(const Il2CppData& from);
  Il2CppData(Il2CppData&& from) noexcept
    : Il2CppData() {
    *this = ::std::move(from);
  }

  inline Il2CppData& operator=(const Il2CppData& from) {
    CopyFrom(from);
    return *this;
  }
  inline Il2CppData& operator=(Il2CppData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Il2CppData& default_instance() {
    return *internal_default_instance();
  }
  static inline const Il2CppData* internal_default_instance() {
    return reinterpret_cast<const Il2CppData*>(
               &_Il2CppData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Il2CppData& a, Il2CppData& b) {
    a.Swap(&b);
  }
  inline void Swap(Il2CppData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Il2CppData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Il2CppData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Il2CppData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Il2CppData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Il2CppData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Il2CppData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Il2CppData";
  }
  protected:
  explicit Il2CppData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Il2CppData_Type Type;
  static constexpr Type PRIMITIVE =
    Il2CppData_Type_PRIMITIVE;
  static constexpr Type STRUCT =
    Il2CppData_Type_STRUCT;
  static constexpr Type CLASS =
    Il2CppData_Type_CLASS;
  static inline bool Type_IsValid(int value) {
    return Il2CppData_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Il2CppData_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Il2CppData_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Il2CppData_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Il2CppData_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Il2CppData_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Il2CppData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kTypeInfoFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .Il2CppClassInfo typeInfo = 2;
  bool has_typeinfo() const;
  private:
  bool _internal_has_typeinfo() const;
  public:
  void clear_typeinfo();
  const ::Il2CppClassInfo& typeinfo() const;
  PROTOBUF_NODISCARD ::Il2CppClassInfo* release_typeinfo();
  ::Il2CppClassInfo* mutable_typeinfo();
  void set_allocated_typeinfo(::Il2CppClassInfo* typeinfo);
  private:
  const ::Il2CppClassInfo& _internal_typeinfo() const;
  ::Il2CppClassInfo* _internal_mutable_typeinfo();
  public:
  void unsafe_arena_set_allocated_typeinfo(
      ::Il2CppClassInfo* typeinfo);
  ::Il2CppClassInfo* unsafe_arena_release_typeinfo();

  // .Il2CppData.Type type = 1;
  void clear_type();
  ::Il2CppData_Type type() const;
  void set_type(::Il2CppData_Type value);
  private:
  ::Il2CppData_Type _internal_type() const;
  void _internal_set_type(::Il2CppData_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Il2CppData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::Il2CppClassInfo* typeinfo_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class InvokeMethod final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InvokeMethod) */ {
 public:
  inline InvokeMethod() : InvokeMethod(nullptr) {}
  ~InvokeMethod() override;
  explicit constexpr InvokeMethod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeMethod(const InvokeMethod& from);
  InvokeMethod(InvokeMethod&& from) noexcept
    : InvokeMethod() {
    *this = ::std::move(from);
  }

  inline InvokeMethod& operator=(const InvokeMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeMethod& operator=(InvokeMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeMethod* internal_default_instance() {
    return reinterpret_cast<const InvokeMethod*>(
               &_InvokeMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InvokeMethod& a, InvokeMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeMethod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeMethod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeMethod>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeMethod& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeMethod& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeMethod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InvokeMethod";
  }
  protected:
  explicit InvokeMethod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kMethodIdFieldNumber = 1,
    kInvokeUUIDFieldNumber = 2,
  };
  // repeated .Il2CppData args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::Il2CppData* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >*
      mutable_args();
  private:
  const ::Il2CppData& _internal_args(int index) const;
  ::Il2CppData* _internal_add_args();
  public:
  const ::Il2CppData& args(int index) const;
  ::Il2CppData* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >&
      args() const;

  // uint64 methodId = 1;
  void clear_methodid();
  uint64_t methodid() const;
  void set_methodid(uint64_t value);
  private:
  uint64_t _internal_methodid() const;
  void _internal_set_methodid(uint64_t value);
  public:

  // uint64 invokeUUID = 2;
  void clear_invokeuuid();
  uint64_t invokeuuid() const;
  void set_invokeuuid(uint64_t value);
  private:
  uint64_t _internal_invokeuuid() const;
  void _internal_set_invokeuuid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:InvokeMethod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData > args_;
  uint64_t methodid_;
  uint64_t invokeuuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class InvokeMethodResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InvokeMethodResult) */ {
 public:
  inline InvokeMethodResult() : InvokeMethodResult(nullptr) {}
  ~InvokeMethodResult() override;
  explicit constexpr InvokeMethodResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeMethodResult(const InvokeMethodResult& from);
  InvokeMethodResult(InvokeMethodResult&& from) noexcept
    : InvokeMethodResult() {
    *this = ::std::move(from);
  }

  inline InvokeMethodResult& operator=(const InvokeMethodResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeMethodResult& operator=(InvokeMethodResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeMethodResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeMethodResult* internal_default_instance() {
    return reinterpret_cast<const InvokeMethodResult*>(
               &_InvokeMethodResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InvokeMethodResult& a, InvokeMethodResult& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeMethodResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeMethodResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeMethodResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeMethodResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeMethodResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeMethodResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeMethodResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InvokeMethodResult";
  }
  protected:
  explicit InvokeMethodResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InvokeMethodResult_Status Status;
  static constexpr Status OK =
    InvokeMethodResult_Status_OK;
  static constexpr Status ERR =
    InvokeMethodResult_Status_ERR;
  static constexpr Status NOT_FOUND =
    InvokeMethodResult_Status_NOT_FOUND;
  static inline bool Status_IsValid(int value) {
    return InvokeMethodResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    InvokeMethodResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    InvokeMethodResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    InvokeMethodResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return InvokeMethodResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return InvokeMethodResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return InvokeMethodResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 5,
    kResultFieldNumber = 4,
    kMethodIdFieldNumber = 2,
    kInvokeUUIDFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // string error = 5;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .Il2CppData result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::Il2CppData& result() const;
  PROTOBUF_NODISCARD ::Il2CppData* release_result();
  ::Il2CppData* mutable_result();
  void set_allocated_result(::Il2CppData* result);
  private:
  const ::Il2CppData& _internal_result() const;
  ::Il2CppData* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::Il2CppData* result);
  ::Il2CppData* unsafe_arena_release_result();

  // uint64 methodId = 2;
  void clear_methodid();
  uint64_t methodid() const;
  void set_methodid(uint64_t value);
  private:
  uint64_t _internal_methodid() const;
  void _internal_set_methodid(uint64_t value);
  public:

  // uint64 invokeUUID = 3;
  void clear_invokeuuid();
  uint64_t invokeuuid() const;
  void set_invokeuuid(uint64_t value);
  private:
  uint64_t _internal_invokeuuid() const;
  void _internal_set_invokeuuid(uint64_t value);
  public:

  // .InvokeMethodResult.Status status = 1;
  void clear_status();
  ::InvokeMethodResult_Status status() const;
  void set_status(::InvokeMethodResult_Status value);
  private:
  ::InvokeMethodResult_Status _internal_status() const;
  void _internal_set_status(::InvokeMethodResult_Status value);
  public:

  // @@protoc_insertion_point(class_scope:InvokeMethodResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::Il2CppData* result_;
  uint64_t methodid_;
  uint64_t invokeuuid_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class SearchObjects final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchObjects) */ {
 public:
  inline SearchObjects() : SearchObjects(nullptr) {}
  ~SearchObjects() override;
  explicit constexpr SearchObjects(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchObjects(const SearchObjects& from);
  SearchObjects(SearchObjects&& from) noexcept
    : SearchObjects() {
    *this = ::std::move(from);
  }

  inline SearchObjects& operator=(const SearchObjects& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchObjects& operator=(SearchObjects&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchObjects& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchObjects* internal_default_instance() {
    return reinterpret_cast<const SearchObjects*>(
               &_SearchObjects_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SearchObjects& a, SearchObjects& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchObjects* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchObjects* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchObjects* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchObjects>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchObjects& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchObjects& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchObjects* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchObjects";
  }
  protected:
  explicit SearchObjects(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectNameFieldNumber = 2,
    kRequiredComponentFieldNumber = 3,
    kQueryIdFieldNumber = 1,
  };
  // string objectName = 2;
  void clear_objectname();
  const std::string& objectname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_objectname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_objectname();
  PROTOBUF_NODISCARD std::string* release_objectname();
  void set_allocated_objectname(std::string* objectname);
  private:
  const std::string& _internal_objectname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_objectname(const std::string& value);
  std::string* _internal_mutable_objectname();
  public:

  // .Il2CppClassInfo requiredComponent = 3;
  bool has_requiredcomponent() const;
  private:
  bool _internal_has_requiredcomponent() const;
  public:
  void clear_requiredcomponent();
  const ::Il2CppClassInfo& requiredcomponent() const;
  PROTOBUF_NODISCARD ::Il2CppClassInfo* release_requiredcomponent();
  ::Il2CppClassInfo* mutable_requiredcomponent();
  void set_allocated_requiredcomponent(::Il2CppClassInfo* requiredcomponent);
  private:
  const ::Il2CppClassInfo& _internal_requiredcomponent() const;
  ::Il2CppClassInfo* _internal_mutable_requiredcomponent();
  public:
  void unsafe_arena_set_allocated_requiredcomponent(
      ::Il2CppClassInfo* requiredcomponent);
  ::Il2CppClassInfo* unsafe_arena_release_requiredcomponent();

  // uint64 queryId = 1;
  void clear_queryid();
  uint64_t queryid() const;
  void set_queryid(uint64_t value);
  private:
  uint64_t _internal_queryid() const;
  void _internal_set_queryid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SearchObjects)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectname_;
  ::Il2CppClassInfo* requiredcomponent_;
  uint64_t queryid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class SearchObjectsResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchObjectsResult) */ {
 public:
  inline SearchObjectsResult() : SearchObjectsResult(nullptr) {}
  ~SearchObjectsResult() override;
  explicit constexpr SearchObjectsResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchObjectsResult(const SearchObjectsResult& from);
  SearchObjectsResult(SearchObjectsResult&& from) noexcept
    : SearchObjectsResult() {
    *this = ::std::move(from);
  }

  inline SearchObjectsResult& operator=(const SearchObjectsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchObjectsResult& operator=(SearchObjectsResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchObjectsResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchObjectsResult* internal_default_instance() {
    return reinterpret_cast<const SearchObjectsResult*>(
               &_SearchObjectsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SearchObjectsResult& a, SearchObjectsResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchObjectsResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchObjectsResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchObjectsResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchObjectsResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchObjectsResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchObjectsResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchObjectsResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchObjectsResult";
  }
  protected:
  explicit SearchObjectsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFoundObjectsFieldNumber = 2,
    kQueryIdFieldNumber = 1,
  };
  // repeated string foundObjects = 2;
  int foundobjects_size() const;
  private:
  int _internal_foundobjects_size() const;
  public:
  void clear_foundobjects();
  const std::string& foundobjects(int index) const;
  std::string* mutable_foundobjects(int index);
  void set_foundobjects(int index, const std::string& value);
  void set_foundobjects(int index, std::string&& value);
  void set_foundobjects(int index, const char* value);
  void set_foundobjects(int index, const char* value, size_t size);
  std::string* add_foundobjects();
  void add_foundobjects(const std::string& value);
  void add_foundobjects(std::string&& value);
  void add_foundobjects(const char* value);
  void add_foundobjects(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& foundobjects() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_foundobjects();
  private:
  const std::string& _internal_foundobjects(int index) const;
  std::string* _internal_add_foundobjects();
  public:

  // uint64 queryId = 1;
  void clear_queryid();
  uint64_t queryid() const;
  void set_queryid(uint64_t value);
  private:
  uint64_t _internal_queryid() const;
  void _internal_set_queryid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SearchObjectsResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> foundobjects_;
  uint64_t queryid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class LoadObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoadObject) */ {
 public:
  inline LoadObject() : LoadObject(nullptr) {}
  ~LoadObject() override;
  explicit constexpr LoadObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadObject(const LoadObject& from);
  LoadObject(LoadObject&& from) noexcept
    : LoadObject() {
    *this = ::std::move(from);
  }

  inline LoadObject& operator=(const LoadObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadObject& operator=(LoadObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadObject* internal_default_instance() {
    return reinterpret_cast<const LoadObject*>(
               &_LoadObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LoadObject& a, LoadObject& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadObject& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoadObject";
  }
  protected:
  explicit LoadObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointerFieldNumber = 2,
    kLoadIdFieldNumber = 1,
  };
  // bytes pointer = 2;
  void clear_pointer();
  const std::string& pointer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pointer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pointer();
  PROTOBUF_NODISCARD std::string* release_pointer();
  void set_allocated_pointer(std::string* pointer);
  private:
  const std::string& _internal_pointer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pointer(const std::string& value);
  std::string* _internal_mutable_pointer();
  public:

  // uint64 loadId = 1;
  void clear_loadid();
  uint64_t loadid() const;
  void set_loadid(uint64_t value);
  private:
  uint64_t _internal_loadid() const;
  void _internal_set_loadid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:LoadObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pointer_;
  uint64_t loadid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class LoadObjectResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoadObjectResult) */ {
 public:
  inline LoadObjectResult() : LoadObjectResult(nullptr) {}
  ~LoadObjectResult() override;
  explicit constexpr LoadObjectResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadObjectResult(const LoadObjectResult& from);
  LoadObjectResult(LoadObjectResult&& from) noexcept
    : LoadObjectResult() {
    *this = ::std::move(from);
  }

  inline LoadObjectResult& operator=(const LoadObjectResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadObjectResult& operator=(LoadObjectResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadObjectResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadObjectResult* internal_default_instance() {
    return reinterpret_cast<const LoadObjectResult*>(
               &_LoadObjectResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LoadObjectResult& a, LoadObjectResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadObjectResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadObjectResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadObjectResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoadObjectResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadObjectResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadObjectResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadObjectResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoadObjectResult";
  }
  protected:
  explicit LoadObjectResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kLoadIdFieldNumber = 1,
  };
  // .Il2CppType object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::Il2CppType& object() const;
  PROTOBUF_NODISCARD ::Il2CppType* release_object();
  ::Il2CppType* mutable_object();
  void set_allocated_object(::Il2CppType* object);
  private:
  const ::Il2CppType& _internal_object() const;
  ::Il2CppType* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::Il2CppType* object);
  ::Il2CppType* unsafe_arena_release_object();

  // uint64 loadId = 1;
  void clear_loadid();
  uint64_t loadid() const;
  void set_loadid(uint64_t value);
  private:
  uint64_t _internal_loadid() const;
  void _internal_set_loadid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:LoadObjectResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Il2CppType* object_;
  uint64_t loadid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_qrue_2eproto;
};
// -------------------------------------------------------------------

class PacketWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PacketWrapper) */ {
 public:
  inline PacketWrapper() : PacketWrapper(nullptr) {}
  ~PacketWrapper() override;
  explicit constexpr PacketWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketWrapper(const PacketWrapper& from);
  PacketWrapper(PacketWrapper&& from) noexcept
    : PacketWrapper() {
    *this = ::std::move(from);
  }

  inline PacketWrapper& operator=(const PacketWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketWrapper& operator=(PacketWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketWrapper& default_instance() {
    return *internal_default_instance();
  }
  enum PacketCase {
    kInvokeMethod = 1,
    kInvokeMethodResult = 2,
    kSearchObjects = 3,
    kSearchObjectsResult = 4,
    kLoadObject = 5,
    kLoadObjectResult = 6,
    PACKET_NOT_SET = 0,
  };

  static inline const PacketWrapper* internal_default_instance() {
    return reinterpret_cast<const PacketWrapper*>(
               &_PacketWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PacketWrapper& a, PacketWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PacketWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PacketWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketWrapper& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PacketWrapper";
  }
  protected:
  explicit PacketWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvokeMethodFieldNumber = 1,
    kInvokeMethodResultFieldNumber = 2,
    kSearchObjectsFieldNumber = 3,
    kSearchObjectsResultFieldNumber = 4,
    kLoadObjectFieldNumber = 5,
    kLoadObjectResultFieldNumber = 6,
  };
  // .InvokeMethod invokeMethod = 1;
  bool has_invokemethod() const;
  private:
  bool _internal_has_invokemethod() const;
  public:
  void clear_invokemethod();
  const ::InvokeMethod& invokemethod() const;
  PROTOBUF_NODISCARD ::InvokeMethod* release_invokemethod();
  ::InvokeMethod* mutable_invokemethod();
  void set_allocated_invokemethod(::InvokeMethod* invokemethod);
  private:
  const ::InvokeMethod& _internal_invokemethod() const;
  ::InvokeMethod* _internal_mutable_invokemethod();
  public:
  void unsafe_arena_set_allocated_invokemethod(
      ::InvokeMethod* invokemethod);
  ::InvokeMethod* unsafe_arena_release_invokemethod();

  // .InvokeMethodResult invokeMethodResult = 2;
  bool has_invokemethodresult() const;
  private:
  bool _internal_has_invokemethodresult() const;
  public:
  void clear_invokemethodresult();
  const ::InvokeMethodResult& invokemethodresult() const;
  PROTOBUF_NODISCARD ::InvokeMethodResult* release_invokemethodresult();
  ::InvokeMethodResult* mutable_invokemethodresult();
  void set_allocated_invokemethodresult(::InvokeMethodResult* invokemethodresult);
  private:
  const ::InvokeMethodResult& _internal_invokemethodresult() const;
  ::InvokeMethodResult* _internal_mutable_invokemethodresult();
  public:
  void unsafe_arena_set_allocated_invokemethodresult(
      ::InvokeMethodResult* invokemethodresult);
  ::InvokeMethodResult* unsafe_arena_release_invokemethodresult();

  // .SearchObjects searchObjects = 3;
  bool has_searchobjects() const;
  private:
  bool _internal_has_searchobjects() const;
  public:
  void clear_searchobjects();
  const ::SearchObjects& searchobjects() const;
  PROTOBUF_NODISCARD ::SearchObjects* release_searchobjects();
  ::SearchObjects* mutable_searchobjects();
  void set_allocated_searchobjects(::SearchObjects* searchobjects);
  private:
  const ::SearchObjects& _internal_searchobjects() const;
  ::SearchObjects* _internal_mutable_searchobjects();
  public:
  void unsafe_arena_set_allocated_searchobjects(
      ::SearchObjects* searchobjects);
  ::SearchObjects* unsafe_arena_release_searchobjects();

  // .SearchObjectsResult searchObjectsResult = 4;
  bool has_searchobjectsresult() const;
  private:
  bool _internal_has_searchobjectsresult() const;
  public:
  void clear_searchobjectsresult();
  const ::SearchObjectsResult& searchobjectsresult() const;
  PROTOBUF_NODISCARD ::SearchObjectsResult* release_searchobjectsresult();
  ::SearchObjectsResult* mutable_searchobjectsresult();
  void set_allocated_searchobjectsresult(::SearchObjectsResult* searchobjectsresult);
  private:
  const ::SearchObjectsResult& _internal_searchobjectsresult() const;
  ::SearchObjectsResult* _internal_mutable_searchobjectsresult();
  public:
  void unsafe_arena_set_allocated_searchobjectsresult(
      ::SearchObjectsResult* searchobjectsresult);
  ::SearchObjectsResult* unsafe_arena_release_searchobjectsresult();

  // .LoadObject loadObject = 5;
  bool has_loadobject() const;
  private:
  bool _internal_has_loadobject() const;
  public:
  void clear_loadobject();
  const ::LoadObject& loadobject() const;
  PROTOBUF_NODISCARD ::LoadObject* release_loadobject();
  ::LoadObject* mutable_loadobject();
  void set_allocated_loadobject(::LoadObject* loadobject);
  private:
  const ::LoadObject& _internal_loadobject() const;
  ::LoadObject* _internal_mutable_loadobject();
  public:
  void unsafe_arena_set_allocated_loadobject(
      ::LoadObject* loadobject);
  ::LoadObject* unsafe_arena_release_loadobject();

  // .LoadObjectResult loadObjectResult = 6;
  bool has_loadobjectresult() const;
  private:
  bool _internal_has_loadobjectresult() const;
  public:
  void clear_loadobjectresult();
  const ::LoadObjectResult& loadobjectresult() const;
  PROTOBUF_NODISCARD ::LoadObjectResult* release_loadobjectresult();
  ::LoadObjectResult* mutable_loadobjectresult();
  void set_allocated_loadobjectresult(::LoadObjectResult* loadobjectresult);
  private:
  const ::LoadObjectResult& _internal_loadobjectresult() const;
  ::LoadObjectResult* _internal_mutable_loadobjectresult();
  public:
  void unsafe_arena_set_allocated_loadobjectresult(
      ::LoadObjectResult* loadobjectresult);
  ::LoadObjectResult* unsafe_arena_release_loadobjectresult();

  void clear_Packet();
  PacketCase Packet_case() const;
  // @@protoc_insertion_point(class_scope:PacketWrapper)
 private:
  class _Internal;
  void set_has_invokemethod();
  void set_has_invokemethodresult();
  void set_has_searchobjects();
  void set_has_searchobjectsresult();
  void set_has_loadobject();
  void set_has_loadobjectresult();

  inline bool has_Packet() const;
  inline void clear_has_Packet();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PacketUnion {
    constexpr PacketUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::InvokeMethod* invokemethod_;
    ::InvokeMethodResult* invokemethodresult_;
    ::SearchObjects* searchobjects_;
    ::SearchObjectsResult* searchobjectsresult_;
    ::LoadObject* loadobject_;
    ::LoadObjectResult* loadobjectresult_;
  } Packet_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_qrue_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Il2CppClassInfo

// string namespaze = 1;
inline void Il2CppClassInfo::clear_namespaze() {
  namespaze_.ClearToEmpty();
}
inline const std::string& Il2CppClassInfo::namespaze() const {
  // @@protoc_insertion_point(field_get:Il2CppClassInfo.namespaze)
  return _internal_namespaze();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppClassInfo::set_namespaze(ArgT0&& arg0, ArgT... args) {
 
 namespaze_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppClassInfo.namespaze)
}
inline std::string* Il2CppClassInfo::mutable_namespaze() {
  std::string* _s = _internal_mutable_namespaze();
  // @@protoc_insertion_point(field_mutable:Il2CppClassInfo.namespaze)
  return _s;
}
inline const std::string& Il2CppClassInfo::_internal_namespaze() const {
  return namespaze_.Get();
}
inline void Il2CppClassInfo::_internal_set_namespaze(const std::string& value) {
  
  namespaze_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppClassInfo::_internal_mutable_namespaze() {
  
  return namespaze_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppClassInfo::release_namespaze() {
  // @@protoc_insertion_point(field_release:Il2CppClassInfo.namespaze)
  return namespaze_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppClassInfo::set_allocated_namespaze(std::string* namespaze) {
  if (namespaze != nullptr) {
    
  } else {
    
  }
  namespaze_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespaze,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespaze_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespaze_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppClassInfo.namespaze)
}

// string clazz = 2;
inline void Il2CppClassInfo::clear_clazz() {
  clazz_.ClearToEmpty();
}
inline const std::string& Il2CppClassInfo::clazz() const {
  // @@protoc_insertion_point(field_get:Il2CppClassInfo.clazz)
  return _internal_clazz();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppClassInfo::set_clazz(ArgT0&& arg0, ArgT... args) {
 
 clazz_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppClassInfo.clazz)
}
inline std::string* Il2CppClassInfo::mutable_clazz() {
  std::string* _s = _internal_mutable_clazz();
  // @@protoc_insertion_point(field_mutable:Il2CppClassInfo.clazz)
  return _s;
}
inline const std::string& Il2CppClassInfo::_internal_clazz() const {
  return clazz_.Get();
}
inline void Il2CppClassInfo::_internal_set_clazz(const std::string& value) {
  
  clazz_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppClassInfo::_internal_mutable_clazz() {
  
  return clazz_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppClassInfo::release_clazz() {
  // @@protoc_insertion_point(field_release:Il2CppClassInfo.clazz)
  return clazz_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppClassInfo::set_allocated_clazz(std::string* clazz) {
  if (clazz != nullptr) {
    
  } else {
    
  }
  clazz_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clazz,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clazz_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clazz_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppClassInfo.clazz)
}

// -------------------------------------------------------------------

// TypeInfo

// .TypeInfo.Type type = 1;
inline void TypeInfo::clear_type() {
  type_ = 0;
}
inline ::TypeInfo_Type TypeInfo::_internal_type() const {
  return static_cast< ::TypeInfo_Type >(type_);
}
inline ::TypeInfo_Type TypeInfo::type() const {
  // @@protoc_insertion_point(field_get:TypeInfo.type)
  return _internal_type();
}
inline void TypeInfo::_internal_set_type(::TypeInfo_Type value) {
  
  type_ = value;
}
inline void TypeInfo::set_type(::TypeInfo_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TypeInfo.type)
}

// .TypeInfo.Primitive primitiveType = 2;
inline void TypeInfo::clear_primitivetype() {
  primitivetype_ = 0;
}
inline ::TypeInfo_Primitive TypeInfo::_internal_primitivetype() const {
  return static_cast< ::TypeInfo_Primitive >(primitivetype_);
}
inline ::TypeInfo_Primitive TypeInfo::primitivetype() const {
  // @@protoc_insertion_point(field_get:TypeInfo.primitiveType)
  return _internal_primitivetype();
}
inline void TypeInfo::_internal_set_primitivetype(::TypeInfo_Primitive value) {
  
  primitivetype_ = value;
}
inline void TypeInfo::set_primitivetype(::TypeInfo_Primitive value) {
  _internal_set_primitivetype(value);
  // @@protoc_insertion_point(field_set:TypeInfo.primitiveType)
}

// .Il2CppClassInfo classInfo = 3;
inline bool TypeInfo::_internal_has_classinfo() const {
  return this != internal_default_instance() && classinfo_ != nullptr;
}
inline bool TypeInfo::has_classinfo() const {
  return _internal_has_classinfo();
}
inline void TypeInfo::clear_classinfo() {
  if (GetArenaForAllocation() == nullptr && classinfo_ != nullptr) {
    delete classinfo_;
  }
  classinfo_ = nullptr;
}
inline const ::Il2CppClassInfo& TypeInfo::_internal_classinfo() const {
  const ::Il2CppClassInfo* p = classinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppClassInfo&>(
      ::_Il2CppClassInfo_default_instance_);
}
inline const ::Il2CppClassInfo& TypeInfo::classinfo() const {
  // @@protoc_insertion_point(field_get:TypeInfo.classInfo)
  return _internal_classinfo();
}
inline void TypeInfo::unsafe_arena_set_allocated_classinfo(
    ::Il2CppClassInfo* classinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(classinfo_);
  }
  classinfo_ = classinfo;
  if (classinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TypeInfo.classInfo)
}
inline ::Il2CppClassInfo* TypeInfo::release_classinfo() {
  
  ::Il2CppClassInfo* temp = classinfo_;
  classinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppClassInfo* TypeInfo::unsafe_arena_release_classinfo() {
  // @@protoc_insertion_point(field_release:TypeInfo.classInfo)
  
  ::Il2CppClassInfo* temp = classinfo_;
  classinfo_ = nullptr;
  return temp;
}
inline ::Il2CppClassInfo* TypeInfo::_internal_mutable_classinfo() {
  
  if (classinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppClassInfo>(GetArenaForAllocation());
    classinfo_ = p;
  }
  return classinfo_;
}
inline ::Il2CppClassInfo* TypeInfo::mutable_classinfo() {
  ::Il2CppClassInfo* _msg = _internal_mutable_classinfo();
  // @@protoc_insertion_point(field_mutable:TypeInfo.classInfo)
  return _msg;
}
inline void TypeInfo::set_allocated_classinfo(::Il2CppClassInfo* classinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete classinfo_;
  }
  if (classinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppClassInfo>::GetOwningArena(classinfo);
    if (message_arena != submessage_arena) {
      classinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, classinfo, submessage_arena);
    }
    
  } else {
    
  }
  classinfo_ = classinfo;
  // @@protoc_insertion_point(field_set_allocated:TypeInfo.classInfo)
}

// -------------------------------------------------------------------

// Il2CppFieldInfo

// string name = 1;
inline void Il2CppFieldInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Il2CppFieldInfo::name() const {
  // @@protoc_insertion_point(field_get:Il2CppFieldInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppFieldInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppFieldInfo.name)
}
inline std::string* Il2CppFieldInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Il2CppFieldInfo.name)
  return _s;
}
inline const std::string& Il2CppFieldInfo::_internal_name() const {
  return name_.Get();
}
inline void Il2CppFieldInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppFieldInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppFieldInfo::release_name() {
  // @@protoc_insertion_point(field_release:Il2CppFieldInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppFieldInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppFieldInfo.name)
}

// string id = 2;
inline void Il2CppFieldInfo::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Il2CppFieldInfo::id() const {
  // @@protoc_insertion_point(field_get:Il2CppFieldInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppFieldInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppFieldInfo.id)
}
inline std::string* Il2CppFieldInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Il2CppFieldInfo.id)
  return _s;
}
inline const std::string& Il2CppFieldInfo::_internal_id() const {
  return id_.Get();
}
inline void Il2CppFieldInfo::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppFieldInfo::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppFieldInfo::release_id() {
  // @@protoc_insertion_point(field_release:Il2CppFieldInfo.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppFieldInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppFieldInfo.id)
}

// .Il2CppData type = 3;
inline bool Il2CppFieldInfo::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Il2CppFieldInfo::has_type() const {
  return _internal_has_type();
}
inline void Il2CppFieldInfo::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::Il2CppData& Il2CppFieldInfo::_internal_type() const {
  const ::Il2CppData* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppData&>(
      ::_Il2CppData_default_instance_);
}
inline const ::Il2CppData& Il2CppFieldInfo::type() const {
  // @@protoc_insertion_point(field_get:Il2CppFieldInfo.type)
  return _internal_type();
}
inline void Il2CppFieldInfo::unsafe_arena_set_allocated_type(
    ::Il2CppData* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Il2CppFieldInfo.type)
}
inline ::Il2CppData* Il2CppFieldInfo::release_type() {
  
  ::Il2CppData* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppData* Il2CppFieldInfo::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:Il2CppFieldInfo.type)
  
  ::Il2CppData* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::Il2CppData* Il2CppFieldInfo::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppData>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::Il2CppData* Il2CppFieldInfo::mutable_type() {
  ::Il2CppData* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:Il2CppFieldInfo.type)
  return _msg;
}
inline void Il2CppFieldInfo::set_allocated_type(::Il2CppData* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppData>::GetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Il2CppFieldInfo.type)
}

// -------------------------------------------------------------------

// Il2CppPropertyInfo

// string name = 1;
inline void Il2CppPropertyInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Il2CppPropertyInfo::name() const {
  // @@protoc_insertion_point(field_get:Il2CppPropertyInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppPropertyInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppPropertyInfo.name)
}
inline std::string* Il2CppPropertyInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Il2CppPropertyInfo.name)
  return _s;
}
inline const std::string& Il2CppPropertyInfo::_internal_name() const {
  return name_.Get();
}
inline void Il2CppPropertyInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppPropertyInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppPropertyInfo::release_name() {
  // @@protoc_insertion_point(field_release:Il2CppPropertyInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppPropertyInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppPropertyInfo.name)
}

// string id = 2;
inline void Il2CppPropertyInfo::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Il2CppPropertyInfo::id() const {
  // @@protoc_insertion_point(field_get:Il2CppPropertyInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppPropertyInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppPropertyInfo.id)
}
inline std::string* Il2CppPropertyInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Il2CppPropertyInfo.id)
  return _s;
}
inline const std::string& Il2CppPropertyInfo::_internal_id() const {
  return id_.Get();
}
inline void Il2CppPropertyInfo::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppPropertyInfo::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppPropertyInfo::release_id() {
  // @@protoc_insertion_point(field_release:Il2CppPropertyInfo.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppPropertyInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppPropertyInfo.id)
}

// bool hasGet = 3;
inline void Il2CppPropertyInfo::clear_hasget() {
  hasget_ = false;
}
inline bool Il2CppPropertyInfo::_internal_hasget() const {
  return hasget_;
}
inline bool Il2CppPropertyInfo::hasget() const {
  // @@protoc_insertion_point(field_get:Il2CppPropertyInfo.hasGet)
  return _internal_hasget();
}
inline void Il2CppPropertyInfo::_internal_set_hasget(bool value) {
  
  hasget_ = value;
}
inline void Il2CppPropertyInfo::set_hasget(bool value) {
  _internal_set_hasget(value);
  // @@protoc_insertion_point(field_set:Il2CppPropertyInfo.hasGet)
}

// bool hasSet = 4;
inline void Il2CppPropertyInfo::clear_hasset() {
  hasset_ = false;
}
inline bool Il2CppPropertyInfo::_internal_hasset() const {
  return hasset_;
}
inline bool Il2CppPropertyInfo::hasset() const {
  // @@protoc_insertion_point(field_get:Il2CppPropertyInfo.hasSet)
  return _internal_hasset();
}
inline void Il2CppPropertyInfo::_internal_set_hasset(bool value) {
  
  hasset_ = value;
}
inline void Il2CppPropertyInfo::set_hasset(bool value) {
  _internal_set_hasset(value);
  // @@protoc_insertion_point(field_set:Il2CppPropertyInfo.hasSet)
}

// .Il2CppData type = 5;
inline bool Il2CppPropertyInfo::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Il2CppPropertyInfo::has_type() const {
  return _internal_has_type();
}
inline void Il2CppPropertyInfo::clear_type() {
  if (GetArenaForAllocation() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::Il2CppData& Il2CppPropertyInfo::_internal_type() const {
  const ::Il2CppData* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppData&>(
      ::_Il2CppData_default_instance_);
}
inline const ::Il2CppData& Il2CppPropertyInfo::type() const {
  // @@protoc_insertion_point(field_get:Il2CppPropertyInfo.type)
  return _internal_type();
}
inline void Il2CppPropertyInfo::unsafe_arena_set_allocated_type(
    ::Il2CppData* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Il2CppPropertyInfo.type)
}
inline ::Il2CppData* Il2CppPropertyInfo::release_type() {
  
  ::Il2CppData* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppData* Il2CppPropertyInfo::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:Il2CppPropertyInfo.type)
  
  ::Il2CppData* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::Il2CppData* Il2CppPropertyInfo::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppData>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::Il2CppData* Il2CppPropertyInfo::mutable_type() {
  ::Il2CppData* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:Il2CppPropertyInfo.type)
  return _msg;
}
inline void Il2CppPropertyInfo::set_allocated_type(::Il2CppData* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppData>::GetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Il2CppPropertyInfo.type)
}

// -------------------------------------------------------------------

// Il2CppMethodInfo

// string name = 1;
inline void Il2CppMethodInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Il2CppMethodInfo::name() const {
  // @@protoc_insertion_point(field_get:Il2CppMethodInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppMethodInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppMethodInfo.name)
}
inline std::string* Il2CppMethodInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Il2CppMethodInfo.name)
  return _s;
}
inline const std::string& Il2CppMethodInfo::_internal_name() const {
  return name_.Get();
}
inline void Il2CppMethodInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppMethodInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppMethodInfo::release_name() {
  // @@protoc_insertion_point(field_release:Il2CppMethodInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppMethodInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppMethodInfo.name)
}

// uint64 id = 2;
inline void Il2CppMethodInfo::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Il2CppMethodInfo::_internal_id() const {
  return id_;
}
inline uint64_t Il2CppMethodInfo::id() const {
  // @@protoc_insertion_point(field_get:Il2CppMethodInfo.id)
  return _internal_id();
}
inline void Il2CppMethodInfo::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Il2CppMethodInfo::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Il2CppMethodInfo.id)
}

// repeated string argNames = 3;
inline int Il2CppMethodInfo::_internal_argnames_size() const {
  return argnames_.size();
}
inline int Il2CppMethodInfo::argnames_size() const {
  return _internal_argnames_size();
}
inline void Il2CppMethodInfo::clear_argnames() {
  argnames_.Clear();
}
inline std::string* Il2CppMethodInfo::add_argnames() {
  std::string* _s = _internal_add_argnames();
  // @@protoc_insertion_point(field_add_mutable:Il2CppMethodInfo.argNames)
  return _s;
}
inline const std::string& Il2CppMethodInfo::_internal_argnames(int index) const {
  return argnames_.Get(index);
}
inline const std::string& Il2CppMethodInfo::argnames(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppMethodInfo.argNames)
  return _internal_argnames(index);
}
inline std::string* Il2CppMethodInfo::mutable_argnames(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppMethodInfo.argNames)
  return argnames_.Mutable(index);
}
inline void Il2CppMethodInfo::set_argnames(int index, const std::string& value) {
  argnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Il2CppMethodInfo.argNames)
}
inline void Il2CppMethodInfo::set_argnames(int index, std::string&& value) {
  argnames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Il2CppMethodInfo.argNames)
}
inline void Il2CppMethodInfo::set_argnames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  argnames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Il2CppMethodInfo.argNames)
}
inline void Il2CppMethodInfo::set_argnames(int index, const char* value, size_t size) {
  argnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Il2CppMethodInfo.argNames)
}
inline std::string* Il2CppMethodInfo::_internal_add_argnames() {
  return argnames_.Add();
}
inline void Il2CppMethodInfo::add_argnames(const std::string& value) {
  argnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Il2CppMethodInfo.argNames)
}
inline void Il2CppMethodInfo::add_argnames(std::string&& value) {
  argnames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Il2CppMethodInfo.argNames)
}
inline void Il2CppMethodInfo::add_argnames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  argnames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Il2CppMethodInfo.argNames)
}
inline void Il2CppMethodInfo::add_argnames(const char* value, size_t size) {
  argnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Il2CppMethodInfo.argNames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Il2CppMethodInfo::argnames() const {
  // @@protoc_insertion_point(field_list:Il2CppMethodInfo.argNames)
  return argnames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Il2CppMethodInfo::mutable_argnames() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppMethodInfo.argNames)
  return &argnames_;
}

// repeated .Il2CppData argTypes = 4;
inline int Il2CppMethodInfo::_internal_argtypes_size() const {
  return argtypes_.size();
}
inline int Il2CppMethodInfo::argtypes_size() const {
  return _internal_argtypes_size();
}
inline void Il2CppMethodInfo::clear_argtypes() {
  argtypes_.Clear();
}
inline ::Il2CppData* Il2CppMethodInfo::mutable_argtypes(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppMethodInfo.argTypes)
  return argtypes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >*
Il2CppMethodInfo::mutable_argtypes() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppMethodInfo.argTypes)
  return &argtypes_;
}
inline const ::Il2CppData& Il2CppMethodInfo::_internal_argtypes(int index) const {
  return argtypes_.Get(index);
}
inline const ::Il2CppData& Il2CppMethodInfo::argtypes(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppMethodInfo.argTypes)
  return _internal_argtypes(index);
}
inline ::Il2CppData* Il2CppMethodInfo::_internal_add_argtypes() {
  return argtypes_.Add();
}
inline ::Il2CppData* Il2CppMethodInfo::add_argtypes() {
  ::Il2CppData* _add = _internal_add_argtypes();
  // @@protoc_insertion_point(field_add:Il2CppMethodInfo.argTypes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >&
Il2CppMethodInfo::argtypes() const {
  // @@protoc_insertion_point(field_list:Il2CppMethodInfo.argTypes)
  return argtypes_;
}

// -------------------------------------------------------------------

// Il2CppType

// string namespaze = 1;
inline void Il2CppType::clear_namespaze() {
  namespaze_.ClearToEmpty();
}
inline const std::string& Il2CppType::namespaze() const {
  // @@protoc_insertion_point(field_get:Il2CppType.namespaze)
  return _internal_namespaze();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppType::set_namespaze(ArgT0&& arg0, ArgT... args) {
 
 namespaze_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppType.namespaze)
}
inline std::string* Il2CppType::mutable_namespaze() {
  std::string* _s = _internal_mutable_namespaze();
  // @@protoc_insertion_point(field_mutable:Il2CppType.namespaze)
  return _s;
}
inline const std::string& Il2CppType::_internal_namespaze() const {
  return namespaze_.Get();
}
inline void Il2CppType::_internal_set_namespaze(const std::string& value) {
  
  namespaze_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppType::_internal_mutable_namespaze() {
  
  return namespaze_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppType::release_namespaze() {
  // @@protoc_insertion_point(field_release:Il2CppType.namespaze)
  return namespaze_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppType::set_allocated_namespaze(std::string* namespaze) {
  if (namespaze != nullptr) {
    
  } else {
    
  }
  namespaze_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespaze,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespaze_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespaze_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppType.namespaze)
}

// string clazz = 2;
inline void Il2CppType::clear_clazz() {
  clazz_.ClearToEmpty();
}
inline const std::string& Il2CppType::clazz() const {
  // @@protoc_insertion_point(field_get:Il2CppType.clazz)
  return _internal_clazz();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppType::set_clazz(ArgT0&& arg0, ArgT... args) {
 
 clazz_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppType.clazz)
}
inline std::string* Il2CppType::mutable_clazz() {
  std::string* _s = _internal_mutable_clazz();
  // @@protoc_insertion_point(field_mutable:Il2CppType.clazz)
  return _s;
}
inline const std::string& Il2CppType::_internal_clazz() const {
  return clazz_.Get();
}
inline void Il2CppType::_internal_set_clazz(const std::string& value) {
  
  clazz_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppType::_internal_mutable_clazz() {
  
  return clazz_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppType::release_clazz() {
  // @@protoc_insertion_point(field_release:Il2CppType.clazz)
  return clazz_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppType::set_allocated_clazz(std::string* clazz) {
  if (clazz != nullptr) {
    
  } else {
    
  }
  clazz_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clazz,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clazz_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clazz_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppType.clazz)
}

// repeated .Il2CppClassInfo generics = 3;
inline int Il2CppType::_internal_generics_size() const {
  return generics_.size();
}
inline int Il2CppType::generics_size() const {
  return _internal_generics_size();
}
inline void Il2CppType::clear_generics() {
  generics_.Clear();
}
inline ::Il2CppClassInfo* Il2CppType::mutable_generics(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppType.generics)
  return generics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppClassInfo >*
Il2CppType::mutable_generics() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppType.generics)
  return &generics_;
}
inline const ::Il2CppClassInfo& Il2CppType::_internal_generics(int index) const {
  return generics_.Get(index);
}
inline const ::Il2CppClassInfo& Il2CppType::generics(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppType.generics)
  return _internal_generics(index);
}
inline ::Il2CppClassInfo* Il2CppType::_internal_add_generics() {
  return generics_.Add();
}
inline ::Il2CppClassInfo* Il2CppType::add_generics() {
  ::Il2CppClassInfo* _add = _internal_add_generics();
  // @@protoc_insertion_point(field_add:Il2CppType.generics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppClassInfo >&
Il2CppType::generics() const {
  // @@protoc_insertion_point(field_list:Il2CppType.generics)
  return generics_;
}

// .Il2CppType parent = 4;
inline bool Il2CppType::_internal_has_parent() const {
  return this != internal_default_instance() && parent_ != nullptr;
}
inline bool Il2CppType::has_parent() const {
  return _internal_has_parent();
}
inline void Il2CppType::clear_parent() {
  if (GetArenaForAllocation() == nullptr && parent_ != nullptr) {
    delete parent_;
  }
  parent_ = nullptr;
}
inline const ::Il2CppType& Il2CppType::_internal_parent() const {
  const ::Il2CppType* p = parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppType&>(
      ::_Il2CppType_default_instance_);
}
inline const ::Il2CppType& Il2CppType::parent() const {
  // @@protoc_insertion_point(field_get:Il2CppType.parent)
  return _internal_parent();
}
inline void Il2CppType::unsafe_arena_set_allocated_parent(
    ::Il2CppType* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_);
  }
  parent_ = parent;
  if (parent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Il2CppType.parent)
}
inline ::Il2CppType* Il2CppType::release_parent() {
  
  ::Il2CppType* temp = parent_;
  parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppType* Il2CppType::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:Il2CppType.parent)
  
  ::Il2CppType* temp = parent_;
  parent_ = nullptr;
  return temp;
}
inline ::Il2CppType* Il2CppType::_internal_mutable_parent() {
  
  if (parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppType>(GetArenaForAllocation());
    parent_ = p;
  }
  return parent_;
}
inline ::Il2CppType* Il2CppType::mutable_parent() {
  ::Il2CppType* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:Il2CppType.parent)
  return _msg;
}
inline void Il2CppType::set_allocated_parent(::Il2CppType* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppType>::GetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    
  } else {
    
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:Il2CppType.parent)
}

// repeated .Il2CppType interfaces = 5;
inline int Il2CppType::_internal_interfaces_size() const {
  return interfaces_.size();
}
inline int Il2CppType::interfaces_size() const {
  return _internal_interfaces_size();
}
inline void Il2CppType::clear_interfaces() {
  interfaces_.Clear();
}
inline ::Il2CppType* Il2CppType::mutable_interfaces(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppType.interfaces)
  return interfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppType >*
Il2CppType::mutable_interfaces() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppType.interfaces)
  return &interfaces_;
}
inline const ::Il2CppType& Il2CppType::_internal_interfaces(int index) const {
  return interfaces_.Get(index);
}
inline const ::Il2CppType& Il2CppType::interfaces(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppType.interfaces)
  return _internal_interfaces(index);
}
inline ::Il2CppType* Il2CppType::_internal_add_interfaces() {
  return interfaces_.Add();
}
inline ::Il2CppType* Il2CppType::add_interfaces() {
  ::Il2CppType* _add = _internal_add_interfaces();
  // @@protoc_insertion_point(field_add:Il2CppType.interfaces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppType >&
Il2CppType::interfaces() const {
  // @@protoc_insertion_point(field_list:Il2CppType.interfaces)
  return interfaces_;
}

// repeated .Il2CppFieldInfo fields = 6;
inline int Il2CppType::_internal_fields_size() const {
  return fields_.size();
}
inline int Il2CppType::fields_size() const {
  return _internal_fields_size();
}
inline void Il2CppType::clear_fields() {
  fields_.Clear();
}
inline ::Il2CppFieldInfo* Il2CppType::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppType.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppFieldInfo >*
Il2CppType::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppType.fields)
  return &fields_;
}
inline const ::Il2CppFieldInfo& Il2CppType::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::Il2CppFieldInfo& Il2CppType::fields(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppType.fields)
  return _internal_fields(index);
}
inline ::Il2CppFieldInfo* Il2CppType::_internal_add_fields() {
  return fields_.Add();
}
inline ::Il2CppFieldInfo* Il2CppType::add_fields() {
  ::Il2CppFieldInfo* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:Il2CppType.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppFieldInfo >&
Il2CppType::fields() const {
  // @@protoc_insertion_point(field_list:Il2CppType.fields)
  return fields_;
}

// repeated .Il2CppPropertyInfo properties = 7;
inline int Il2CppType::_internal_properties_size() const {
  return properties_.size();
}
inline int Il2CppType::properties_size() const {
  return _internal_properties_size();
}
inline void Il2CppType::clear_properties() {
  properties_.Clear();
}
inline ::Il2CppPropertyInfo* Il2CppType::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppType.properties)
  return properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppPropertyInfo >*
Il2CppType::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppType.properties)
  return &properties_;
}
inline const ::Il2CppPropertyInfo& Il2CppType::_internal_properties(int index) const {
  return properties_.Get(index);
}
inline const ::Il2CppPropertyInfo& Il2CppType::properties(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppType.properties)
  return _internal_properties(index);
}
inline ::Il2CppPropertyInfo* Il2CppType::_internal_add_properties() {
  return properties_.Add();
}
inline ::Il2CppPropertyInfo* Il2CppType::add_properties() {
  ::Il2CppPropertyInfo* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:Il2CppType.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppPropertyInfo >&
Il2CppType::properties() const {
  // @@protoc_insertion_point(field_list:Il2CppType.properties)
  return properties_;
}

// repeated .Il2CppMethodInfo methods = 8;
inline int Il2CppType::_internal_methods_size() const {
  return methods_.size();
}
inline int Il2CppType::methods_size() const {
  return _internal_methods_size();
}
inline void Il2CppType::clear_methods() {
  methods_.Clear();
}
inline ::Il2CppMethodInfo* Il2CppType::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:Il2CppType.methods)
  return methods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppMethodInfo >*
Il2CppType::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:Il2CppType.methods)
  return &methods_;
}
inline const ::Il2CppMethodInfo& Il2CppType::_internal_methods(int index) const {
  return methods_.Get(index);
}
inline const ::Il2CppMethodInfo& Il2CppType::methods(int index) const {
  // @@protoc_insertion_point(field_get:Il2CppType.methods)
  return _internal_methods(index);
}
inline ::Il2CppMethodInfo* Il2CppType::_internal_add_methods() {
  return methods_.Add();
}
inline ::Il2CppMethodInfo* Il2CppType::add_methods() {
  ::Il2CppMethodInfo* _add = _internal_add_methods();
  // @@protoc_insertion_point(field_add:Il2CppType.methods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppMethodInfo >&
Il2CppType::methods() const {
  // @@protoc_insertion_point(field_list:Il2CppType.methods)
  return methods_;
}

// -------------------------------------------------------------------

// Il2CppData

// .Il2CppData.Type type = 1;
inline void Il2CppData::clear_type() {
  type_ = 0;
}
inline ::Il2CppData_Type Il2CppData::_internal_type() const {
  return static_cast< ::Il2CppData_Type >(type_);
}
inline ::Il2CppData_Type Il2CppData::type() const {
  // @@protoc_insertion_point(field_get:Il2CppData.type)
  return _internal_type();
}
inline void Il2CppData::_internal_set_type(::Il2CppData_Type value) {
  
  type_ = value;
}
inline void Il2CppData::set_type(::Il2CppData_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Il2CppData.type)
}

// .Il2CppClassInfo typeInfo = 2;
inline bool Il2CppData::_internal_has_typeinfo() const {
  return this != internal_default_instance() && typeinfo_ != nullptr;
}
inline bool Il2CppData::has_typeinfo() const {
  return _internal_has_typeinfo();
}
inline void Il2CppData::clear_typeinfo() {
  if (GetArenaForAllocation() == nullptr && typeinfo_ != nullptr) {
    delete typeinfo_;
  }
  typeinfo_ = nullptr;
}
inline const ::Il2CppClassInfo& Il2CppData::_internal_typeinfo() const {
  const ::Il2CppClassInfo* p = typeinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppClassInfo&>(
      ::_Il2CppClassInfo_default_instance_);
}
inline const ::Il2CppClassInfo& Il2CppData::typeinfo() const {
  // @@protoc_insertion_point(field_get:Il2CppData.typeInfo)
  return _internal_typeinfo();
}
inline void Il2CppData::unsafe_arena_set_allocated_typeinfo(
    ::Il2CppClassInfo* typeinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(typeinfo_);
  }
  typeinfo_ = typeinfo;
  if (typeinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Il2CppData.typeInfo)
}
inline ::Il2CppClassInfo* Il2CppData::release_typeinfo() {
  
  ::Il2CppClassInfo* temp = typeinfo_;
  typeinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppClassInfo* Il2CppData::unsafe_arena_release_typeinfo() {
  // @@protoc_insertion_point(field_release:Il2CppData.typeInfo)
  
  ::Il2CppClassInfo* temp = typeinfo_;
  typeinfo_ = nullptr;
  return temp;
}
inline ::Il2CppClassInfo* Il2CppData::_internal_mutable_typeinfo() {
  
  if (typeinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppClassInfo>(GetArenaForAllocation());
    typeinfo_ = p;
  }
  return typeinfo_;
}
inline ::Il2CppClassInfo* Il2CppData::mutable_typeinfo() {
  ::Il2CppClassInfo* _msg = _internal_mutable_typeinfo();
  // @@protoc_insertion_point(field_mutable:Il2CppData.typeInfo)
  return _msg;
}
inline void Il2CppData::set_allocated_typeinfo(::Il2CppClassInfo* typeinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete typeinfo_;
  }
  if (typeinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppClassInfo>::GetOwningArena(typeinfo);
    if (message_arena != submessage_arena) {
      typeinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, typeinfo, submessage_arena);
    }
    
  } else {
    
  }
  typeinfo_ = typeinfo;
  // @@protoc_insertion_point(field_set_allocated:Il2CppData.typeInfo)
}

// bytes data = 3;
inline void Il2CppData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Il2CppData::data() const {
  // @@protoc_insertion_point(field_get:Il2CppData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Il2CppData::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Il2CppData.data)
}
inline std::string* Il2CppData::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Il2CppData.data)
  return _s;
}
inline const std::string& Il2CppData::_internal_data() const {
  return data_.Get();
}
inline void Il2CppData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Il2CppData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Il2CppData::release_data() {
  // @@protoc_insertion_point(field_release:Il2CppData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Il2CppData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Il2CppData.data)
}

// -------------------------------------------------------------------

// InvokeMethod

// uint64 methodId = 1;
inline void InvokeMethod::clear_methodid() {
  methodid_ = uint64_t{0u};
}
inline uint64_t InvokeMethod::_internal_methodid() const {
  return methodid_;
}
inline uint64_t InvokeMethod::methodid() const {
  // @@protoc_insertion_point(field_get:InvokeMethod.methodId)
  return _internal_methodid();
}
inline void InvokeMethod::_internal_set_methodid(uint64_t value) {
  
  methodid_ = value;
}
inline void InvokeMethod::set_methodid(uint64_t value) {
  _internal_set_methodid(value);
  // @@protoc_insertion_point(field_set:InvokeMethod.methodId)
}

// uint64 invokeUUID = 2;
inline void InvokeMethod::clear_invokeuuid() {
  invokeuuid_ = uint64_t{0u};
}
inline uint64_t InvokeMethod::_internal_invokeuuid() const {
  return invokeuuid_;
}
inline uint64_t InvokeMethod::invokeuuid() const {
  // @@protoc_insertion_point(field_get:InvokeMethod.invokeUUID)
  return _internal_invokeuuid();
}
inline void InvokeMethod::_internal_set_invokeuuid(uint64_t value) {
  
  invokeuuid_ = value;
}
inline void InvokeMethod::set_invokeuuid(uint64_t value) {
  _internal_set_invokeuuid(value);
  // @@protoc_insertion_point(field_set:InvokeMethod.invokeUUID)
}

// repeated .Il2CppData args = 3;
inline int InvokeMethod::_internal_args_size() const {
  return args_.size();
}
inline int InvokeMethod::args_size() const {
  return _internal_args_size();
}
inline void InvokeMethod::clear_args() {
  args_.Clear();
}
inline ::Il2CppData* InvokeMethod::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:InvokeMethod.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >*
InvokeMethod::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:InvokeMethod.args)
  return &args_;
}
inline const ::Il2CppData& InvokeMethod::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::Il2CppData& InvokeMethod::args(int index) const {
  // @@protoc_insertion_point(field_get:InvokeMethod.args)
  return _internal_args(index);
}
inline ::Il2CppData* InvokeMethod::_internal_add_args() {
  return args_.Add();
}
inline ::Il2CppData* InvokeMethod::add_args() {
  ::Il2CppData* _add = _internal_add_args();
  // @@protoc_insertion_point(field_add:InvokeMethod.args)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Il2CppData >&
InvokeMethod::args() const {
  // @@protoc_insertion_point(field_list:InvokeMethod.args)
  return args_;
}

// -------------------------------------------------------------------

// InvokeMethodResult

// .InvokeMethodResult.Status status = 1;
inline void InvokeMethodResult::clear_status() {
  status_ = 0;
}
inline ::InvokeMethodResult_Status InvokeMethodResult::_internal_status() const {
  return static_cast< ::InvokeMethodResult_Status >(status_);
}
inline ::InvokeMethodResult_Status InvokeMethodResult::status() const {
  // @@protoc_insertion_point(field_get:InvokeMethodResult.status)
  return _internal_status();
}
inline void InvokeMethodResult::_internal_set_status(::InvokeMethodResult_Status value) {
  
  status_ = value;
}
inline void InvokeMethodResult::set_status(::InvokeMethodResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:InvokeMethodResult.status)
}

// uint64 methodId = 2;
inline void InvokeMethodResult::clear_methodid() {
  methodid_ = uint64_t{0u};
}
inline uint64_t InvokeMethodResult::_internal_methodid() const {
  return methodid_;
}
inline uint64_t InvokeMethodResult::methodid() const {
  // @@protoc_insertion_point(field_get:InvokeMethodResult.methodId)
  return _internal_methodid();
}
inline void InvokeMethodResult::_internal_set_methodid(uint64_t value) {
  
  methodid_ = value;
}
inline void InvokeMethodResult::set_methodid(uint64_t value) {
  _internal_set_methodid(value);
  // @@protoc_insertion_point(field_set:InvokeMethodResult.methodId)
}

// uint64 invokeUUID = 3;
inline void InvokeMethodResult::clear_invokeuuid() {
  invokeuuid_ = uint64_t{0u};
}
inline uint64_t InvokeMethodResult::_internal_invokeuuid() const {
  return invokeuuid_;
}
inline uint64_t InvokeMethodResult::invokeuuid() const {
  // @@protoc_insertion_point(field_get:InvokeMethodResult.invokeUUID)
  return _internal_invokeuuid();
}
inline void InvokeMethodResult::_internal_set_invokeuuid(uint64_t value) {
  
  invokeuuid_ = value;
}
inline void InvokeMethodResult::set_invokeuuid(uint64_t value) {
  _internal_set_invokeuuid(value);
  // @@protoc_insertion_point(field_set:InvokeMethodResult.invokeUUID)
}

// .Il2CppData result = 4;
inline bool InvokeMethodResult::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool InvokeMethodResult::has_result() const {
  return _internal_has_result();
}
inline void InvokeMethodResult::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::Il2CppData& InvokeMethodResult::_internal_result() const {
  const ::Il2CppData* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppData&>(
      ::_Il2CppData_default_instance_);
}
inline const ::Il2CppData& InvokeMethodResult::result() const {
  // @@protoc_insertion_point(field_get:InvokeMethodResult.result)
  return _internal_result();
}
inline void InvokeMethodResult::unsafe_arena_set_allocated_result(
    ::Il2CppData* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InvokeMethodResult.result)
}
inline ::Il2CppData* InvokeMethodResult::release_result() {
  
  ::Il2CppData* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppData* InvokeMethodResult::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:InvokeMethodResult.result)
  
  ::Il2CppData* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::Il2CppData* InvokeMethodResult::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppData>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::Il2CppData* InvokeMethodResult::mutable_result() {
  ::Il2CppData* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:InvokeMethodResult.result)
  return _msg;
}
inline void InvokeMethodResult::set_allocated_result(::Il2CppData* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppData>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:InvokeMethodResult.result)
}

// string error = 5;
inline void InvokeMethodResult::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& InvokeMethodResult::error() const {
  // @@protoc_insertion_point(field_get:InvokeMethodResult.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeMethodResult::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvokeMethodResult.error)
}
inline std::string* InvokeMethodResult::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:InvokeMethodResult.error)
  return _s;
}
inline const std::string& InvokeMethodResult::_internal_error() const {
  return error_.Get();
}
inline void InvokeMethodResult::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeMethodResult::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeMethodResult::release_error() {
  // @@protoc_insertion_point(field_release:InvokeMethodResult.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeMethodResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvokeMethodResult.error)
}

// -------------------------------------------------------------------

// SearchObjects

// uint64 queryId = 1;
inline void SearchObjects::clear_queryid() {
  queryid_ = uint64_t{0u};
}
inline uint64_t SearchObjects::_internal_queryid() const {
  return queryid_;
}
inline uint64_t SearchObjects::queryid() const {
  // @@protoc_insertion_point(field_get:SearchObjects.queryId)
  return _internal_queryid();
}
inline void SearchObjects::_internal_set_queryid(uint64_t value) {
  
  queryid_ = value;
}
inline void SearchObjects::set_queryid(uint64_t value) {
  _internal_set_queryid(value);
  // @@protoc_insertion_point(field_set:SearchObjects.queryId)
}

// string objectName = 2;
inline void SearchObjects::clear_objectname() {
  objectname_.ClearToEmpty();
}
inline const std::string& SearchObjects::objectname() const {
  // @@protoc_insertion_point(field_get:SearchObjects.objectName)
  return _internal_objectname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchObjects::set_objectname(ArgT0&& arg0, ArgT... args) {
 
 objectname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchObjects.objectName)
}
inline std::string* SearchObjects::mutable_objectname() {
  std::string* _s = _internal_mutable_objectname();
  // @@protoc_insertion_point(field_mutable:SearchObjects.objectName)
  return _s;
}
inline const std::string& SearchObjects::_internal_objectname() const {
  return objectname_.Get();
}
inline void SearchObjects::_internal_set_objectname(const std::string& value) {
  
  objectname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchObjects::_internal_mutable_objectname() {
  
  return objectname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchObjects::release_objectname() {
  // @@protoc_insertion_point(field_release:SearchObjects.objectName)
  return objectname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchObjects::set_allocated_objectname(std::string* objectname) {
  if (objectname != nullptr) {
    
  } else {
    
  }
  objectname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), objectname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (objectname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    objectname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SearchObjects.objectName)
}

// .Il2CppClassInfo requiredComponent = 3;
inline bool SearchObjects::_internal_has_requiredcomponent() const {
  return this != internal_default_instance() && requiredcomponent_ != nullptr;
}
inline bool SearchObjects::has_requiredcomponent() const {
  return _internal_has_requiredcomponent();
}
inline void SearchObjects::clear_requiredcomponent() {
  if (GetArenaForAllocation() == nullptr && requiredcomponent_ != nullptr) {
    delete requiredcomponent_;
  }
  requiredcomponent_ = nullptr;
}
inline const ::Il2CppClassInfo& SearchObjects::_internal_requiredcomponent() const {
  const ::Il2CppClassInfo* p = requiredcomponent_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppClassInfo&>(
      ::_Il2CppClassInfo_default_instance_);
}
inline const ::Il2CppClassInfo& SearchObjects::requiredcomponent() const {
  // @@protoc_insertion_point(field_get:SearchObjects.requiredComponent)
  return _internal_requiredcomponent();
}
inline void SearchObjects::unsafe_arena_set_allocated_requiredcomponent(
    ::Il2CppClassInfo* requiredcomponent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(requiredcomponent_);
  }
  requiredcomponent_ = requiredcomponent;
  if (requiredcomponent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SearchObjects.requiredComponent)
}
inline ::Il2CppClassInfo* SearchObjects::release_requiredcomponent() {
  
  ::Il2CppClassInfo* temp = requiredcomponent_;
  requiredcomponent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppClassInfo* SearchObjects::unsafe_arena_release_requiredcomponent() {
  // @@protoc_insertion_point(field_release:SearchObjects.requiredComponent)
  
  ::Il2CppClassInfo* temp = requiredcomponent_;
  requiredcomponent_ = nullptr;
  return temp;
}
inline ::Il2CppClassInfo* SearchObjects::_internal_mutable_requiredcomponent() {
  
  if (requiredcomponent_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppClassInfo>(GetArenaForAllocation());
    requiredcomponent_ = p;
  }
  return requiredcomponent_;
}
inline ::Il2CppClassInfo* SearchObjects::mutable_requiredcomponent() {
  ::Il2CppClassInfo* _msg = _internal_mutable_requiredcomponent();
  // @@protoc_insertion_point(field_mutable:SearchObjects.requiredComponent)
  return _msg;
}
inline void SearchObjects::set_allocated_requiredcomponent(::Il2CppClassInfo* requiredcomponent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete requiredcomponent_;
  }
  if (requiredcomponent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppClassInfo>::GetOwningArena(requiredcomponent);
    if (message_arena != submessage_arena) {
      requiredcomponent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requiredcomponent, submessage_arena);
    }
    
  } else {
    
  }
  requiredcomponent_ = requiredcomponent;
  // @@protoc_insertion_point(field_set_allocated:SearchObjects.requiredComponent)
}

// -------------------------------------------------------------------

// SearchObjectsResult

// uint64 queryId = 1;
inline void SearchObjectsResult::clear_queryid() {
  queryid_ = uint64_t{0u};
}
inline uint64_t SearchObjectsResult::_internal_queryid() const {
  return queryid_;
}
inline uint64_t SearchObjectsResult::queryid() const {
  // @@protoc_insertion_point(field_get:SearchObjectsResult.queryId)
  return _internal_queryid();
}
inline void SearchObjectsResult::_internal_set_queryid(uint64_t value) {
  
  queryid_ = value;
}
inline void SearchObjectsResult::set_queryid(uint64_t value) {
  _internal_set_queryid(value);
  // @@protoc_insertion_point(field_set:SearchObjectsResult.queryId)
}

// repeated string foundObjects = 2;
inline int SearchObjectsResult::_internal_foundobjects_size() const {
  return foundobjects_.size();
}
inline int SearchObjectsResult::foundobjects_size() const {
  return _internal_foundobjects_size();
}
inline void SearchObjectsResult::clear_foundobjects() {
  foundobjects_.Clear();
}
inline std::string* SearchObjectsResult::add_foundobjects() {
  std::string* _s = _internal_add_foundobjects();
  // @@protoc_insertion_point(field_add_mutable:SearchObjectsResult.foundObjects)
  return _s;
}
inline const std::string& SearchObjectsResult::_internal_foundobjects(int index) const {
  return foundobjects_.Get(index);
}
inline const std::string& SearchObjectsResult::foundobjects(int index) const {
  // @@protoc_insertion_point(field_get:SearchObjectsResult.foundObjects)
  return _internal_foundobjects(index);
}
inline std::string* SearchObjectsResult::mutable_foundobjects(int index) {
  // @@protoc_insertion_point(field_mutable:SearchObjectsResult.foundObjects)
  return foundobjects_.Mutable(index);
}
inline void SearchObjectsResult::set_foundobjects(int index, const std::string& value) {
  foundobjects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SearchObjectsResult.foundObjects)
}
inline void SearchObjectsResult::set_foundobjects(int index, std::string&& value) {
  foundobjects_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SearchObjectsResult.foundObjects)
}
inline void SearchObjectsResult::set_foundobjects(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  foundobjects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SearchObjectsResult.foundObjects)
}
inline void SearchObjectsResult::set_foundobjects(int index, const char* value, size_t size) {
  foundobjects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SearchObjectsResult.foundObjects)
}
inline std::string* SearchObjectsResult::_internal_add_foundobjects() {
  return foundobjects_.Add();
}
inline void SearchObjectsResult::add_foundobjects(const std::string& value) {
  foundobjects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SearchObjectsResult.foundObjects)
}
inline void SearchObjectsResult::add_foundobjects(std::string&& value) {
  foundobjects_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SearchObjectsResult.foundObjects)
}
inline void SearchObjectsResult::add_foundobjects(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  foundobjects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SearchObjectsResult.foundObjects)
}
inline void SearchObjectsResult::add_foundobjects(const char* value, size_t size) {
  foundobjects_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SearchObjectsResult.foundObjects)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchObjectsResult::foundobjects() const {
  // @@protoc_insertion_point(field_list:SearchObjectsResult.foundObjects)
  return foundobjects_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchObjectsResult::mutable_foundobjects() {
  // @@protoc_insertion_point(field_mutable_list:SearchObjectsResult.foundObjects)
  return &foundobjects_;
}

// -------------------------------------------------------------------

// LoadObject

// uint64 loadId = 1;
inline void LoadObject::clear_loadid() {
  loadid_ = uint64_t{0u};
}
inline uint64_t LoadObject::_internal_loadid() const {
  return loadid_;
}
inline uint64_t LoadObject::loadid() const {
  // @@protoc_insertion_point(field_get:LoadObject.loadId)
  return _internal_loadid();
}
inline void LoadObject::_internal_set_loadid(uint64_t value) {
  
  loadid_ = value;
}
inline void LoadObject::set_loadid(uint64_t value) {
  _internal_set_loadid(value);
  // @@protoc_insertion_point(field_set:LoadObject.loadId)
}

// bytes pointer = 2;
inline void LoadObject::clear_pointer() {
  pointer_.ClearToEmpty();
}
inline const std::string& LoadObject::pointer() const {
  // @@protoc_insertion_point(field_get:LoadObject.pointer)
  return _internal_pointer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadObject::set_pointer(ArgT0&& arg0, ArgT... args) {
 
 pointer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoadObject.pointer)
}
inline std::string* LoadObject::mutable_pointer() {
  std::string* _s = _internal_mutable_pointer();
  // @@protoc_insertion_point(field_mutable:LoadObject.pointer)
  return _s;
}
inline const std::string& LoadObject::_internal_pointer() const {
  return pointer_.Get();
}
inline void LoadObject::_internal_set_pointer(const std::string& value) {
  
  pointer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadObject::_internal_mutable_pointer() {
  
  return pointer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadObject::release_pointer() {
  // @@protoc_insertion_point(field_release:LoadObject.pointer)
  return pointer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadObject::set_allocated_pointer(std::string* pointer) {
  if (pointer != nullptr) {
    
  } else {
    
  }
  pointer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pointer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pointer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pointer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoadObject.pointer)
}

// -------------------------------------------------------------------

// LoadObjectResult

// uint64 loadId = 1;
inline void LoadObjectResult::clear_loadid() {
  loadid_ = uint64_t{0u};
}
inline uint64_t LoadObjectResult::_internal_loadid() const {
  return loadid_;
}
inline uint64_t LoadObjectResult::loadid() const {
  // @@protoc_insertion_point(field_get:LoadObjectResult.loadId)
  return _internal_loadid();
}
inline void LoadObjectResult::_internal_set_loadid(uint64_t value) {
  
  loadid_ = value;
}
inline void LoadObjectResult::set_loadid(uint64_t value) {
  _internal_set_loadid(value);
  // @@protoc_insertion_point(field_set:LoadObjectResult.loadId)
}

// .Il2CppType object = 2;
inline bool LoadObjectResult::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool LoadObjectResult::has_object() const {
  return _internal_has_object();
}
inline void LoadObjectResult::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::Il2CppType& LoadObjectResult::_internal_object() const {
  const ::Il2CppType* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::Il2CppType&>(
      ::_Il2CppType_default_instance_);
}
inline const ::Il2CppType& LoadObjectResult::object() const {
  // @@protoc_insertion_point(field_get:LoadObjectResult.object)
  return _internal_object();
}
inline void LoadObjectResult::unsafe_arena_set_allocated_object(
    ::Il2CppType* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LoadObjectResult.object)
}
inline ::Il2CppType* LoadObjectResult::release_object() {
  
  ::Il2CppType* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Il2CppType* LoadObjectResult::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:LoadObjectResult.object)
  
  ::Il2CppType* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::Il2CppType* LoadObjectResult::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::Il2CppType>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::Il2CppType* LoadObjectResult::mutable_object() {
  ::Il2CppType* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:LoadObjectResult.object)
  return _msg;
}
inline void LoadObjectResult::set_allocated_object(::Il2CppType* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Il2CppType>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:LoadObjectResult.object)
}

// -------------------------------------------------------------------

// PacketWrapper

// .InvokeMethod invokeMethod = 1;
inline bool PacketWrapper::_internal_has_invokemethod() const {
  return Packet_case() == kInvokeMethod;
}
inline bool PacketWrapper::has_invokemethod() const {
  return _internal_has_invokemethod();
}
inline void PacketWrapper::set_has_invokemethod() {
  _oneof_case_[0] = kInvokeMethod;
}
inline void PacketWrapper::clear_invokemethod() {
  if (_internal_has_invokemethod()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Packet_.invokemethod_;
    }
    clear_has_Packet();
  }
}
inline ::InvokeMethod* PacketWrapper::release_invokemethod() {
  // @@protoc_insertion_point(field_release:PacketWrapper.invokeMethod)
  if (_internal_has_invokemethod()) {
    clear_has_Packet();
      ::InvokeMethod* temp = Packet_.invokemethod_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Packet_.invokemethod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InvokeMethod& PacketWrapper::_internal_invokemethod() const {
  return _internal_has_invokemethod()
      ? *Packet_.invokemethod_
      : reinterpret_cast< ::InvokeMethod&>(::_InvokeMethod_default_instance_);
}
inline const ::InvokeMethod& PacketWrapper::invokemethod() const {
  // @@protoc_insertion_point(field_get:PacketWrapper.invokeMethod)
  return _internal_invokemethod();
}
inline ::InvokeMethod* PacketWrapper::unsafe_arena_release_invokemethod() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PacketWrapper.invokeMethod)
  if (_internal_has_invokemethod()) {
    clear_has_Packet();
    ::InvokeMethod* temp = Packet_.invokemethod_;
    Packet_.invokemethod_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketWrapper::unsafe_arena_set_allocated_invokemethod(::InvokeMethod* invokemethod) {
  clear_Packet();
  if (invokemethod) {
    set_has_invokemethod();
    Packet_.invokemethod_ = invokemethod;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PacketWrapper.invokeMethod)
}
inline ::InvokeMethod* PacketWrapper::_internal_mutable_invokemethod() {
  if (!_internal_has_invokemethod()) {
    clear_Packet();
    set_has_invokemethod();
    Packet_.invokemethod_ = CreateMaybeMessage< ::InvokeMethod >(GetArenaForAllocation());
  }
  return Packet_.invokemethod_;
}
inline ::InvokeMethod* PacketWrapper::mutable_invokemethod() {
  ::InvokeMethod* _msg = _internal_mutable_invokemethod();
  // @@protoc_insertion_point(field_mutable:PacketWrapper.invokeMethod)
  return _msg;
}

// .InvokeMethodResult invokeMethodResult = 2;
inline bool PacketWrapper::_internal_has_invokemethodresult() const {
  return Packet_case() == kInvokeMethodResult;
}
inline bool PacketWrapper::has_invokemethodresult() const {
  return _internal_has_invokemethodresult();
}
inline void PacketWrapper::set_has_invokemethodresult() {
  _oneof_case_[0] = kInvokeMethodResult;
}
inline void PacketWrapper::clear_invokemethodresult() {
  if (_internal_has_invokemethodresult()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Packet_.invokemethodresult_;
    }
    clear_has_Packet();
  }
}
inline ::InvokeMethodResult* PacketWrapper::release_invokemethodresult() {
  // @@protoc_insertion_point(field_release:PacketWrapper.invokeMethodResult)
  if (_internal_has_invokemethodresult()) {
    clear_has_Packet();
      ::InvokeMethodResult* temp = Packet_.invokemethodresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Packet_.invokemethodresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InvokeMethodResult& PacketWrapper::_internal_invokemethodresult() const {
  return _internal_has_invokemethodresult()
      ? *Packet_.invokemethodresult_
      : reinterpret_cast< ::InvokeMethodResult&>(::_InvokeMethodResult_default_instance_);
}
inline const ::InvokeMethodResult& PacketWrapper::invokemethodresult() const {
  // @@protoc_insertion_point(field_get:PacketWrapper.invokeMethodResult)
  return _internal_invokemethodresult();
}
inline ::InvokeMethodResult* PacketWrapper::unsafe_arena_release_invokemethodresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PacketWrapper.invokeMethodResult)
  if (_internal_has_invokemethodresult()) {
    clear_has_Packet();
    ::InvokeMethodResult* temp = Packet_.invokemethodresult_;
    Packet_.invokemethodresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketWrapper::unsafe_arena_set_allocated_invokemethodresult(::InvokeMethodResult* invokemethodresult) {
  clear_Packet();
  if (invokemethodresult) {
    set_has_invokemethodresult();
    Packet_.invokemethodresult_ = invokemethodresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PacketWrapper.invokeMethodResult)
}
inline ::InvokeMethodResult* PacketWrapper::_internal_mutable_invokemethodresult() {
  if (!_internal_has_invokemethodresult()) {
    clear_Packet();
    set_has_invokemethodresult();
    Packet_.invokemethodresult_ = CreateMaybeMessage< ::InvokeMethodResult >(GetArenaForAllocation());
  }
  return Packet_.invokemethodresult_;
}
inline ::InvokeMethodResult* PacketWrapper::mutable_invokemethodresult() {
  ::InvokeMethodResult* _msg = _internal_mutable_invokemethodresult();
  // @@protoc_insertion_point(field_mutable:PacketWrapper.invokeMethodResult)
  return _msg;
}

// .SearchObjects searchObjects = 3;
inline bool PacketWrapper::_internal_has_searchobjects() const {
  return Packet_case() == kSearchObjects;
}
inline bool PacketWrapper::has_searchobjects() const {
  return _internal_has_searchobjects();
}
inline void PacketWrapper::set_has_searchobjects() {
  _oneof_case_[0] = kSearchObjects;
}
inline void PacketWrapper::clear_searchobjects() {
  if (_internal_has_searchobjects()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Packet_.searchobjects_;
    }
    clear_has_Packet();
  }
}
inline ::SearchObjects* PacketWrapper::release_searchobjects() {
  // @@protoc_insertion_point(field_release:PacketWrapper.searchObjects)
  if (_internal_has_searchobjects()) {
    clear_has_Packet();
      ::SearchObjects* temp = Packet_.searchobjects_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Packet_.searchobjects_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SearchObjects& PacketWrapper::_internal_searchobjects() const {
  return _internal_has_searchobjects()
      ? *Packet_.searchobjects_
      : reinterpret_cast< ::SearchObjects&>(::_SearchObjects_default_instance_);
}
inline const ::SearchObjects& PacketWrapper::searchobjects() const {
  // @@protoc_insertion_point(field_get:PacketWrapper.searchObjects)
  return _internal_searchobjects();
}
inline ::SearchObjects* PacketWrapper::unsafe_arena_release_searchobjects() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PacketWrapper.searchObjects)
  if (_internal_has_searchobjects()) {
    clear_has_Packet();
    ::SearchObjects* temp = Packet_.searchobjects_;
    Packet_.searchobjects_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketWrapper::unsafe_arena_set_allocated_searchobjects(::SearchObjects* searchobjects) {
  clear_Packet();
  if (searchobjects) {
    set_has_searchobjects();
    Packet_.searchobjects_ = searchobjects;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PacketWrapper.searchObjects)
}
inline ::SearchObjects* PacketWrapper::_internal_mutable_searchobjects() {
  if (!_internal_has_searchobjects()) {
    clear_Packet();
    set_has_searchobjects();
    Packet_.searchobjects_ = CreateMaybeMessage< ::SearchObjects >(GetArenaForAllocation());
  }
  return Packet_.searchobjects_;
}
inline ::SearchObjects* PacketWrapper::mutable_searchobjects() {
  ::SearchObjects* _msg = _internal_mutable_searchobjects();
  // @@protoc_insertion_point(field_mutable:PacketWrapper.searchObjects)
  return _msg;
}

// .SearchObjectsResult searchObjectsResult = 4;
inline bool PacketWrapper::_internal_has_searchobjectsresult() const {
  return Packet_case() == kSearchObjectsResult;
}
inline bool PacketWrapper::has_searchobjectsresult() const {
  return _internal_has_searchobjectsresult();
}
inline void PacketWrapper::set_has_searchobjectsresult() {
  _oneof_case_[0] = kSearchObjectsResult;
}
inline void PacketWrapper::clear_searchobjectsresult() {
  if (_internal_has_searchobjectsresult()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Packet_.searchobjectsresult_;
    }
    clear_has_Packet();
  }
}
inline ::SearchObjectsResult* PacketWrapper::release_searchobjectsresult() {
  // @@protoc_insertion_point(field_release:PacketWrapper.searchObjectsResult)
  if (_internal_has_searchobjectsresult()) {
    clear_has_Packet();
      ::SearchObjectsResult* temp = Packet_.searchobjectsresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Packet_.searchobjectsresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SearchObjectsResult& PacketWrapper::_internal_searchobjectsresult() const {
  return _internal_has_searchobjectsresult()
      ? *Packet_.searchobjectsresult_
      : reinterpret_cast< ::SearchObjectsResult&>(::_SearchObjectsResult_default_instance_);
}
inline const ::SearchObjectsResult& PacketWrapper::searchobjectsresult() const {
  // @@protoc_insertion_point(field_get:PacketWrapper.searchObjectsResult)
  return _internal_searchobjectsresult();
}
inline ::SearchObjectsResult* PacketWrapper::unsafe_arena_release_searchobjectsresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PacketWrapper.searchObjectsResult)
  if (_internal_has_searchobjectsresult()) {
    clear_has_Packet();
    ::SearchObjectsResult* temp = Packet_.searchobjectsresult_;
    Packet_.searchobjectsresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketWrapper::unsafe_arena_set_allocated_searchobjectsresult(::SearchObjectsResult* searchobjectsresult) {
  clear_Packet();
  if (searchobjectsresult) {
    set_has_searchobjectsresult();
    Packet_.searchobjectsresult_ = searchobjectsresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PacketWrapper.searchObjectsResult)
}
inline ::SearchObjectsResult* PacketWrapper::_internal_mutable_searchobjectsresult() {
  if (!_internal_has_searchobjectsresult()) {
    clear_Packet();
    set_has_searchobjectsresult();
    Packet_.searchobjectsresult_ = CreateMaybeMessage< ::SearchObjectsResult >(GetArenaForAllocation());
  }
  return Packet_.searchobjectsresult_;
}
inline ::SearchObjectsResult* PacketWrapper::mutable_searchobjectsresult() {
  ::SearchObjectsResult* _msg = _internal_mutable_searchobjectsresult();
  // @@protoc_insertion_point(field_mutable:PacketWrapper.searchObjectsResult)
  return _msg;
}

// .LoadObject loadObject = 5;
inline bool PacketWrapper::_internal_has_loadobject() const {
  return Packet_case() == kLoadObject;
}
inline bool PacketWrapper::has_loadobject() const {
  return _internal_has_loadobject();
}
inline void PacketWrapper::set_has_loadobject() {
  _oneof_case_[0] = kLoadObject;
}
inline void PacketWrapper::clear_loadobject() {
  if (_internal_has_loadobject()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Packet_.loadobject_;
    }
    clear_has_Packet();
  }
}
inline ::LoadObject* PacketWrapper::release_loadobject() {
  // @@protoc_insertion_point(field_release:PacketWrapper.loadObject)
  if (_internal_has_loadobject()) {
    clear_has_Packet();
      ::LoadObject* temp = Packet_.loadobject_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Packet_.loadobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoadObject& PacketWrapper::_internal_loadobject() const {
  return _internal_has_loadobject()
      ? *Packet_.loadobject_
      : reinterpret_cast< ::LoadObject&>(::_LoadObject_default_instance_);
}
inline const ::LoadObject& PacketWrapper::loadobject() const {
  // @@protoc_insertion_point(field_get:PacketWrapper.loadObject)
  return _internal_loadobject();
}
inline ::LoadObject* PacketWrapper::unsafe_arena_release_loadobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PacketWrapper.loadObject)
  if (_internal_has_loadobject()) {
    clear_has_Packet();
    ::LoadObject* temp = Packet_.loadobject_;
    Packet_.loadobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketWrapper::unsafe_arena_set_allocated_loadobject(::LoadObject* loadobject) {
  clear_Packet();
  if (loadobject) {
    set_has_loadobject();
    Packet_.loadobject_ = loadobject;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PacketWrapper.loadObject)
}
inline ::LoadObject* PacketWrapper::_internal_mutable_loadobject() {
  if (!_internal_has_loadobject()) {
    clear_Packet();
    set_has_loadobject();
    Packet_.loadobject_ = CreateMaybeMessage< ::LoadObject >(GetArenaForAllocation());
  }
  return Packet_.loadobject_;
}
inline ::LoadObject* PacketWrapper::mutable_loadobject() {
  ::LoadObject* _msg = _internal_mutable_loadobject();
  // @@protoc_insertion_point(field_mutable:PacketWrapper.loadObject)
  return _msg;
}

// .LoadObjectResult loadObjectResult = 6;
inline bool PacketWrapper::_internal_has_loadobjectresult() const {
  return Packet_case() == kLoadObjectResult;
}
inline bool PacketWrapper::has_loadobjectresult() const {
  return _internal_has_loadobjectresult();
}
inline void PacketWrapper::set_has_loadobjectresult() {
  _oneof_case_[0] = kLoadObjectResult;
}
inline void PacketWrapper::clear_loadobjectresult() {
  if (_internal_has_loadobjectresult()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Packet_.loadobjectresult_;
    }
    clear_has_Packet();
  }
}
inline ::LoadObjectResult* PacketWrapper::release_loadobjectresult() {
  // @@protoc_insertion_point(field_release:PacketWrapper.loadObjectResult)
  if (_internal_has_loadobjectresult()) {
    clear_has_Packet();
      ::LoadObjectResult* temp = Packet_.loadobjectresult_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Packet_.loadobjectresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LoadObjectResult& PacketWrapper::_internal_loadobjectresult() const {
  return _internal_has_loadobjectresult()
      ? *Packet_.loadobjectresult_
      : reinterpret_cast< ::LoadObjectResult&>(::_LoadObjectResult_default_instance_);
}
inline const ::LoadObjectResult& PacketWrapper::loadobjectresult() const {
  // @@protoc_insertion_point(field_get:PacketWrapper.loadObjectResult)
  return _internal_loadobjectresult();
}
inline ::LoadObjectResult* PacketWrapper::unsafe_arena_release_loadobjectresult() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PacketWrapper.loadObjectResult)
  if (_internal_has_loadobjectresult()) {
    clear_has_Packet();
    ::LoadObjectResult* temp = Packet_.loadobjectresult_;
    Packet_.loadobjectresult_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PacketWrapper::unsafe_arena_set_allocated_loadobjectresult(::LoadObjectResult* loadobjectresult) {
  clear_Packet();
  if (loadobjectresult) {
    set_has_loadobjectresult();
    Packet_.loadobjectresult_ = loadobjectresult;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PacketWrapper.loadObjectResult)
}
inline ::LoadObjectResult* PacketWrapper::_internal_mutable_loadobjectresult() {
  if (!_internal_has_loadobjectresult()) {
    clear_Packet();
    set_has_loadobjectresult();
    Packet_.loadobjectresult_ = CreateMaybeMessage< ::LoadObjectResult >(GetArenaForAllocation());
  }
  return Packet_.loadobjectresult_;
}
inline ::LoadObjectResult* PacketWrapper::mutable_loadobjectresult() {
  ::LoadObjectResult* _msg = _internal_mutable_loadobjectresult();
  // @@protoc_insertion_point(field_mutable:PacketWrapper.loadObjectResult)
  return _msg;
}

inline bool PacketWrapper::has_Packet() const {
  return Packet_case() != PACKET_NOT_SET;
}
inline void PacketWrapper::clear_has_Packet() {
  _oneof_case_[0] = PACKET_NOT_SET;
}
inline PacketWrapper::PacketCase PacketWrapper::Packet_case() const {
  return PacketWrapper::PacketCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TypeInfo_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TypeInfo_Type>() {
  return ::TypeInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::TypeInfo_Primitive> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TypeInfo_Primitive>() {
  return ::TypeInfo_Primitive_descriptor();
}
template <> struct is_proto_enum< ::Il2CppData_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Il2CppData_Type>() {
  return ::Il2CppData_Type_descriptor();
}
template <> struct is_proto_enum< ::InvokeMethodResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::InvokeMethodResult_Status>() {
  return ::InvokeMethodResult_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_qrue_2eproto
